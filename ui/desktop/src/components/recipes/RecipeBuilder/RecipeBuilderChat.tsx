import { useEffect, useRef, useState, useCallback } from 'react';
import { Message, startAgent, recipeToYaml } from '../../../api';
import { Recipe, stripEmptyExtensions } from '../../../recipe';
import { useChatStream } from '../../../hooks/useChatStream';
import { ChatState } from '../../../types/chatState';
import { ScrollArea, ScrollAreaHandle } from '../../ui/scroll-area';
import ProgressiveMessageList from '../../ProgressiveMessageList';
import LoadingGoose from '../../LoadingGoose';
import { recipeBuilderRecipe } from './recipeBuilderRecipe';
import { extractYamlFromMessage, parseYamlToRecipe } from './recipeExtractor';
import { getInitialWorkingDir } from '../../../utils/workingDir';
import { UserInput } from '../../../types/message';
import { Send } from 'lucide-react';
import { Button } from '../../ui/button';
import { RecipeBuilderChatProps } from './types';

export default function RecipeBuilderChat({ recipe, onRecipeChange }: RecipeBuilderChatProps) {
  const [sessionId, setSessionId] = useState<string | null>(null);
  const [sessionError, setSessionError] = useState<string | null>(null);
  const [isInitializing, setIsInitializing] = useState(true);
  const [inputValue, setInputValue] = useState('');
  const scrollRef = useRef<ScrollAreaHandle>(null);
  const inputRef = useRef<HTMLTextAreaElement>(null);
  const lastExtractedYamlRef = useRef<string | null>(null);
  // Track the last recipe generated by the AI (for detecting user edits in Edit view)
  const lastAIRecipeRef = useRef<Recipe | null>(null);

  useEffect(() => {
    let cancelled = false;

    (async () => {
      try {
        const workingDir = getInitialWorkingDir();
        const response = await startAgent({
          body: {
            working_dir: workingDir,
            recipe: stripEmptyExtensions(recipeBuilderRecipe),
          },
          throwOnError: true,
        });

        if (cancelled) return;

        setSessionId(response.data.id);
        setIsInitializing(false);
      } catch (error) {
        if (cancelled) return;
        console.error('Failed to start recipe builder session:', error);
        setSessionError(error instanceof Error ? error.message : 'Failed to start session');
        setIsInitializing(false);
      }
    })();

    return () => {
      cancelled = true;
    };
  }, []);

  const onStreamFinish = useCallback(() => {}, []);

  const {
    messages,
    chatState,
    handleSubmit: submitToChat,
    sessionLoadError,
    stopStreaming,
  } = useChatStream({
    sessionId: sessionId || '',
    onStreamFinish,
  });

  // Only extract recipe when streaming is complete to avoid parsing incomplete YAML
  useEffect(() => {
    if (messages.length === 0) return;
    if (chatState !== ChatState.Idle) return; // Wait for streaming to complete

    const lastMessage = messages[messages.length - 1];
    if (lastMessage.role !== 'assistant') return;

    const yamlString = extractYamlFromMessage(lastMessage);
    if (!yamlString || yamlString === lastExtractedYamlRef.current) return;

    lastExtractedYamlRef.current = yamlString;

    (async () => {
      const extractedRecipe = await parseYamlToRecipe(yamlString);
      if (extractedRecipe) {
        // Track the last AI-generated recipe for detecting user edits
        lastAIRecipeRef.current = extractedRecipe;
        onRecipeChange(extractedRecipe);
      }
    })();
  }, [messages, chatState, onRecipeChange]);

  const isUserMessage = useCallback((message: Message) => message.role === 'user', []);

  useEffect(() => {
    if (!isInitializing && chatState === ChatState.Idle && inputRef.current) {
      inputRef.current.focus();
    }
  }, [isInitializing, chatState]);

  const isLoading = isInitializing || chatState === ChatState.LoadingConversation;
  const isStreaming =
    chatState === ChatState.Streaming ||
    chatState === ChatState.Thinking ||
    chatState === ChatState.Compacting;

  const handleSubmit = useCallback(async () => {
    if (!inputValue.trim() || isStreaming) return;

    let messageText = inputValue;

    // Check if the recipe was edited in the Edit view (different from last AI-generated)
    const wasEditedExternally =
      recipe !== null && JSON.stringify(recipe) !== JSON.stringify(lastAIRecipeRef.current);

    if (wasEditedExternally) {
      try {
        // Convert current recipe to YAML and prepend as context
        const response = await recipeToYaml({ body: { recipe } });
        if (response.data?.yaml) {
          messageText = `I've updated the recipe. Here's the current version:\n\n\`\`\`yaml\n${response.data.yaml}\`\`\`\n\n${inputValue}`;
          // Update lastAIRecipeRef to the current recipe to avoid prepending again
          lastAIRecipeRef.current = recipe;
        }
      } catch (error) {
        console.error('Failed to convert recipe to YAML:', error);
        // Continue without prepending if conversion fails
      }
    }

    const input: UserInput = { msg: messageText, images: [] };
    submitToChat(input);
    setInputValue('');
  }, [inputValue, isStreaming, submitToChat, recipe]);

  const handleKeyDown = useCallback(
    (e: React.KeyboardEvent) => {
      if (e.key === 'Enter' && !e.shiftKey) {
        e.preventDefault();
        handleSubmit();
      }
    },
    [handleSubmit]
  );

  if (sessionError || sessionLoadError) {
    return (
      <div className="flex-1 flex items-center justify-center p-8">
        <div className="text-red-700 dark:text-red-300 bg-red-400/50 p-4 rounded-lg max-w-md">
          <h3 className="font-semibold mb-2">Failed to Start Chat</h3>
          <p className="text-sm">{sessionError || sessionLoadError}</p>
        </div>
      </div>
    );
  }

  if (isLoading) {
    return (
      <div className="flex-1 flex items-center justify-center">
        <LoadingGoose />
      </div>
    );
  }

  return (
    <div className="flex flex-col flex-1 min-h-0 bg-background-default">
      <ScrollArea ref={scrollRef} className="flex-1 min-h-0 px-4" autoScroll>
        <div className="py-6">
          {messages.length === 0 ? (
            <div className="text-center text-textSubtle py-8">
              <p className="text-lg mb-2">Recipe Builder</p>
              <p className="text-sm">
                Tell me what kind of recipe you'd like to create, and I'll help you build it.
              </p>
            </div>
          ) : (
            <ProgressiveMessageList
              messages={messages}
              chat={{ sessionId: sessionId! }}
              isUserMessage={isUserMessage}
            />
          )}
          {isStreaming && (
            <div className="flex justify-center py-4">
              <LoadingGoose chatState={chatState} />
            </div>
          )}
        </div>
      </ScrollArea>

      <div className="p-4 border-t border-borderSubtle">
        <div className="flex gap-2">
          <textarea
            ref={inputRef}
            value={inputValue}
            onChange={(e) => setInputValue(e.target.value)}
            onKeyDown={handleKeyDown}
            placeholder="Describe the recipe you want to create..."
            className="flex-1 p-3 border border-borderSubtle rounded-lg bg-background-default text-textStandard resize-none focus:outline-none focus:ring-2 focus:ring-blue-500"
            rows={2}
            disabled={isStreaming}
          />
          <div className="flex flex-col gap-2">
            {isStreaming ? (
              <Button onClick={stopStreaming} variant="outline" size="sm" className="h-full">
                Stop
              </Button>
            ) : (
              <Button
                onClick={handleSubmit}
                disabled={!inputValue.trim()}
                size="sm"
                className="h-full"
              >
                <Send className="w-4 h-4" />
              </Button>
            )}
          </div>
        </div>
      </div>
    </div>
  );
}
