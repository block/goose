# goose Release Notes Generator
#
# Automatically generates release notes using goose AI agent when a new release is published.
# Updates the GitHub release with AI-generated categorized notes and posts to Discord.
#
# Trigger: When a GitHub release is published (after release.yml completes)
#
# Required Secrets:
#   - OPENROUTER_API_KEY: API key for OpenRouter
#
# Optional Secrets (for Discord):
#   - DISCORD_BOT_TOKEN: Discord bot token for posting release announcements
#
# Optional Variables:
#   - GOOSE_PROVIDER: LLM provider (default: openrouter)
#   - GOOSE_MODEL: Model name (default: anthropic/claude-sonnet-4)
#   - DISCORD_RELEASE_CHANNEL_ID: Discord channel ID for release announcements

name: goose Release Notes Generator

on:
  release:
    types: [published]

  # Allow manual trigger for testing
  workflow_dispatch:
    inputs:
      tag:
        description: 'Release tag to generate notes for (e.g., v1.25.0)'
        required: true
        type: string

env:
  GOOSE_RECIPE: |
    version: "1.0.0"
    title: "Release Notes Generator"
    description: "Generate release notes for ${RELEASE_TAG}"

    extensions:
      - type: builtin
        name: developer

    instructions: |
      Generate release notes for the goose release.

      ## Process
      1. You are already in the goose repository. Do NOT clone or checkout anything.
      2. Get the previous release tag by running: git describe --tags --abbrev=0 ${RELEASE_TAG}^
      3. Get commits between tags: git log <previous_tag>..${RELEASE_TAG} --oneline --no-merges
      4. Analyze the commits and categorize changes

      ## Output Format
      Categorize changes into these sections (skip empty sections):
      - ‚ú® **Features** - New functionality
      - üêõ **Bug Fixes** - Bug fixes
      - üîß **Improvements** - Enhancements to existing features
      - üìö **Documentation** - Documentation updates

      Format each item as:
      - Concise description [#XXXX](https://github.com/block/goose/pull/XXXX)

      Rules:
      - Extract PR numbers from commit messages (look for (#XXXX) pattern)
      - Remove redundant words like "Added", "Fixed", "Documented" - the category headers make these clear
      - Keep descriptions user-friendly and concise
      - Order: Features ‚Üí Bug Fixes ‚Üí Improvements ‚Üí Documentation

      ## Final Step
      Write ONLY the release notes content to /tmp/release_notes.md (no extra commentary)

    prompt: |
      Generate release notes for ${RELEASE_TAG} in the goose repository.

permissions:
  contents: write

concurrency:
  group: release-notes-${{ github.event.release.tag_name || inputs.tag }}
  cancel-in-progress: true

jobs:
  generate-release-notes:
    name: Generate Release Notes
    runs-on: ubuntu-latest
    # Skip stable tag releases - they're just pointers to versioned releases
    if: ${{ (github.event.release.tag_name || inputs.tag) != 'stable' }}

    container:
      image: ghcr.io/block/goose:latest
      options: --user root
      env:
        GOOSE_PROVIDER: ${{ vars.GOOSE_PROVIDER || 'openrouter' }}
        GOOSE_MODEL: ${{ vars.GOOSE_MODEL || 'anthropic/claude-sonnet-4' }}
        OPENROUTER_API_KEY: ${{ secrets.OPENROUTER_API_KEY }}
        HOME: /tmp/goose-home

    outputs:
      release_notes: ${{ steps.read-notes.outputs.notes }}
      notes_length: ${{ steps.read-notes.outputs.length }}

    steps:
      - name: Checkout repository
        uses: actions/checkout@11bd71901bbe5b1630ceea73d27597364c9af683  # v4.2.2
        with:
          fetch-depth: 0
          fetch-tags: true

      - name: Install tools
        run: |
          apt-get update
          apt-get install -y gettext curl ripgrep git jq

      - name: Run goose to generate release notes
        env:
          RELEASE_TAG: ${{ github.event.release.tag_name || inputs.tag }}
        run: |
          mkdir -p $HOME/.local/share/goose/sessions
          mkdir -p $HOME/.config/goose
          git config --global --add safe.directory "$GITHUB_WORKSPACE"

          # Checkout the release tag
          git checkout "${RELEASE_TAG}"

          # Create recipe from env var with variable substitution
          echo "$GOOSE_RECIPE" | envsubst '$RELEASE_TAG' > /tmp/recipe.yaml

          goose run --recipe /tmp/recipe.yaml

      - name: Read release notes
        id: read-notes
        run: |
          if [ -f /tmp/release_notes.md ]; then
            # Use random delimiter to prevent injection
            DELIMITER="EOF_$(openssl rand -hex 8)"
            echo "notes<<$DELIMITER" >> $GITHUB_OUTPUT
            cat /tmp/release_notes.md >> $GITHUB_OUTPUT
            echo "" >> $GITHUB_OUTPUT
            echo "$DELIMITER" >> $GITHUB_OUTPUT

            LENGTH=$(wc -c < /tmp/release_notes.md)
            echo "length=$LENGTH" >> $GITHUB_OUTPUT

            echo "::notice::Release notes generated successfully (${LENGTH} chars)"
          else
            echo "::error::Release notes file not found at /tmp/release_notes.md"
            echo "notes=Release notes generation failed." >> $GITHUB_OUTPUT
            echo "length=0" >> $GITHUB_OUTPUT
            exit 1
          fi

  update-github-release:
    name: Update GitHub Release
    runs-on: ubuntu-latest
    needs: generate-release-notes
    permissions:
      contents: write

    steps:
      - name: Update release body
        uses: ncipollo/release-action@b7eabc95ff50cbeeedec83973935c8f306dfcd0b  # v1.20.0
        with:
          tag: ${{ github.event.release.tag_name || inputs.tag }}
          token: ${{ secrets.GITHUB_TOKEN }}
          body: ${{ needs.generate-release-notes.outputs.release_notes }}
          allowUpdates: true
          omitNameDuringUpdate: true
          omitPrereleaseDuringUpdate: true

  post-to-discord:
    name: Post to Discord
    runs-on: ubuntu-latest
    needs: generate-release-notes

    steps:
      - name: Post release announcement
        env:
          DISCORD_BOT_TOKEN: ${{ secrets.DISCORD_BOT_TOKEN }}
          DISCORD_CHANNEL_ID: ${{ secrets.DISCORD_RELEASE_CHANNEL_ID }}
          RELEASE_TAG: ${{ github.event.release.tag_name || inputs.tag }}
          RELEASE_URL: ${{ github.event.release.html_url || format('https://github.com/block/goose/releases/tag/{0}', inputs.tag) }}
          RELEASE_NOTES: ${{ needs.generate-release-notes.outputs.release_notes }}
          NOTES_LENGTH: ${{ needs.generate-release-notes.outputs.notes_length }}
        shell: bash
        run: |
          # Skip if Discord is not configured
          if [ -z "$DISCORD_CHANNEL_ID" ] || [ -z "$DISCORD_BOT_TOKEN" ]; then
            echo "::notice::Discord not configured, skipping"
            exit 0
          fi

          # Discord message character limit is ~2000 for regular messages
          SAFE_LIMIT=1800

          # Function to send Discord message via bot API, returns message ID
          send_discord() {
            local content="$1"
            local channel="$2"

            content=$(echo "$content" | jq -Rs .)

            response=$(curl -s -X POST "https://discord.com/api/v10/channels/${channel}/messages" \
              -H "Authorization: Bot ${DISCORD_BOT_TOKEN}" \
              -H "Content-Type: application/json" \
              -d "{\"content\": $content, \"flags\": 4}")

            # Debug: show response if there's an error
            if echo "$response" | jq -e '.code' > /dev/null 2>&1; then
              echo "::warning::Discord API error: $(echo "$response" | jq -c '.')" >&2
            fi

            echo "$response" | jq -r '.id // empty'
          }

          # Function to create a thread from a message
          create_thread() {
            local channel="$1"
            local message_id="$2"
            local thread_name="$3"

            response=$(curl -s -X POST "https://discord.com/api/v10/channels/${channel}/messages/${message_id}/threads" \
              -H "Authorization: Bot ${DISCORD_BOT_TOKEN}" \
              -H "Content-Type: application/json" \
              -d "{\"name\": \"${thread_name}\"}")

            echo "$response" | jq -r '.id // empty'
          }

          # Build the header
          HEADER="## üéâ goose ${RELEASE_TAG} is here!

üì¶ **Download:** ${RELEASE_URL}"

          # Check if we need to thread (notes too long)
          HEADER_LENGTH=${#HEADER}
          TOTAL_LENGTH=$((HEADER_LENGTH + NOTES_LENGTH + 50))

          if [ "$TOTAL_LENGTH" -le "$SAFE_LIMIT" ]; then
            # Single message - full notes fit
            FULL_MESSAGE="${HEADER}

${RELEASE_NOTES}"
            send_discord "$FULL_MESSAGE" "$DISCORD_CHANNEL_ID"
          else
            # Notes too long - include preview in main message, full notes in thread
            echo "Release notes exceed Discord limit (${TOTAL_LENGTH} chars), using thread..."

            # Extract first section (usually Features) for preview
            # Look for content up to the second ## header or take first ~800 chars
            PREVIEW=$(echo "$RELEASE_NOTES" | awk '
              /^## / { if (seen++) exit }
              { print }
            ')
            
            # If preview is too long or empty, just take first ~800 chars at a newline
            if [ ${#PREVIEW} -gt 800 ] || [ -z "$PREVIEW" ]; then
              PREVIEW="${RELEASE_NOTES:0:800}"
              # Break at last newline
              LAST_NL=$(echo "$PREVIEW" | grep -bo $'\n' | tail -1 | cut -d: -f1 || echo "")
              if [ -n "$LAST_NL" ] && [ "$LAST_NL" -gt 200 ]; then
                PREVIEW="${PREVIEW:0:$LAST_NL}"
              fi
            fi

            # Build main message with preview
            MAIN_MESSAGE="${HEADER}

${PREVIEW}

üìù *Full release notes in thread below...*"

            MESSAGE_ID=$(send_discord "$MAIN_MESSAGE" "$DISCORD_CHANNEL_ID")

            if [ -z "$MESSAGE_ID" ]; then
              echo "::error::Failed to send Discord message"
              exit 1
            fi

            echo "Created message $MESSAGE_ID, creating thread..."
            sleep 1

            # Create thread from the message
            THREAD_ID=$(create_thread "$DISCORD_CHANNEL_ID" "$MESSAGE_ID" "Release Notes ${RELEASE_TAG}")

            if [ -z "$THREAD_ID" ]; then
              echo "::warning::Failed to create thread, posting notes as follow-up messages"
              THREAD_ID="$DISCORD_CHANNEL_ID"
            else
              echo "Created thread $THREAD_ID"
            fi

            sleep 1

            # Post release notes in chunks to the thread
            REMAINING="$RELEASE_NOTES"

            while [ -n "$REMAINING" ]; do
              CHUNK="${REMAINING:0:$SAFE_LIMIT}"
              REMAINING="${REMAINING:$SAFE_LIMIT}"

              # Try to break at a newline for cleaner splits
              if [ -n "$REMAINING" ]; then
                LAST_NEWLINE=$(echo "$CHUNK" | tail -c +1000 | grep -bo $'\n' | tail -1 | cut -d: -f1 || echo "")
                if [ -n "$LAST_NEWLINE" ]; then
                  BREAK_POINT=$((1000 + LAST_NEWLINE))
                  REMAINING="${CHUNK:$BREAK_POINT}${REMAINING}"
                  CHUNK="${CHUNK:0:$BREAK_POINT}"
                fi
              fi

              send_discord "$CHUNK" "$THREAD_ID"
              sleep 1
            done
          fi

          echo "::notice::Discord notification sent successfully"
