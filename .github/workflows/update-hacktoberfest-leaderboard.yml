name: Update Hacktoberfest Leaderboard

on:
  schedule:
  # Only during October
    - cron: '0 * * 10 *'  # Runs every hour at the start of the hour during October
  workflow_dispatch:  # Allows manual triggering

jobs:
  update-leaderboard:
    runs-on: ubuntu-latest
    permissions:
      contents: read
      issues: write
    steps:
    - name: Checkout repository
      uses: actions/checkout@v4

    - name: Update Leaderboard
      uses: actions/github-script@v6
      with:
        github-token: ${{ secrets.GITHUB_TOKEN }}
        script: |
          const owner = context.repo.owner;
          const repo = context.repo.repo;
          const issueNumber = 4775; // Your issue number

          // Add your repositories here - you can include any repos you want to track
          const REPOS = [
            'block/goose',
            // Add more repositories as needed, e.g.:
            // 'taniashiba/your-other-repo',
            // 'your-org/another-repo'
          ];

          const POINT_VALUES = {
            small: 5,
            medium: 10,
            large: 15
          };

          const calculatePoints = (labels) => {
            const size = labels.find(label => POINT_VALUES[label.name.toLowerCase()]);
            return size ? POINT_VALUES[size.name.toLowerCase()] : POINT_VALUES.small;
          };

          const getBiggestPRSize = (prs) => {
            const sizes = prs.map(pr => {
              const sizeLabel = pr.labels.find(label => POINT_VALUES[label.name.toLowerCase()]);
              return sizeLabel ? sizeLabel.name.toLowerCase() : 'small';
            });
            
            if (sizes.includes('large')) return 'large';
            if (sizes.includes('medium')) return 'medium';
            return 'small';
          };

          const fetchRecentPRs = async (repo) => {
            try {
              console.log(`🔍 Fetching PRs for ${repo}`);
              const [repoOwner, repoName] = repo.split('/');
              
              // Define October 2025 date range
              const octoberStart = new Date('2025-10-01T00:00:00Z');
              const octoberEnd = new Date('2025-10-31T23:59:59Z');
              
              console.log(`📅 Date range: ${octoberStart.toISOString()} to ${octoberEnd.toISOString()}`);
              
              let allPRs = [];
              let page = 1;
              const perPage = 100;
              let hasMorePages = true;
              
              // Fetch all PRs with pagination
              while (hasMorePages) {
                console.log(`📄 Fetching page ${page} for ${repo}...`);
                
                const { data: prs } = await github.rest.pulls.list({
                  owner: repoOwner,
                  repo: repoName,
                  state: 'closed',
                  sort: 'updated',
                  direction: 'desc',
                  per_page: perPage,
                  page: page
                });

                console.log(`📊 Page ${page}: Found ${prs.length} PRs`);
                
                if (prs.length === 0) {
                  hasMorePages = false;
                  break;
                }
                
                // Check if we've gone beyond October 2025
                const oldestPRDate = new Date(prs[prs.length - 1].updated_at);
                if (oldestPRDate < octoberStart) {
                  console.log(`⏰ Reached PRs older than October 2025, stopping pagination`);
                  // Filter only PRs that are within October 2025
                  const octoberPRs = prs.filter(pr => {
                    const updatedDate = new Date(pr.updated_at);
                    return updatedDate >= octoberStart;
                  });
                  allPRs = allPRs.concat(octoberPRs);
                  hasMorePages = false;
                } else {
                  allPRs = allPRs.concat(prs);
                  page++;
                  
                  // Safety check to prevent infinite loops
                  if (page > 50) {
                    console.log(`⚠️  Reached maximum page limit (50) for ${repo}`);
                    hasMorePages = false;
                  }
                }
              }

              console.log(`📈 Total PRs fetched for ${repo}: ${allPRs.length}`);

              const hacktoberfestPRs = allPRs.filter(pr => {
                const isMerged = !!pr.merged_at;
                
                // Check if merged within October 2025
                const mergedDate = pr.merged_at ? new Date(pr.merged_at) : null;
                const isInOctober2025 = mergedDate && mergedDate >= octoberStart && mergedDate <= octoberEnd;
                
                // Check for specific Hacktoberfest labels
                const isHacktoberfest = pr.labels.some(label => {
                  const labelName = label.name.toLowerCase();
                  return labelName === 'hacktoberfest' || 
                         labelName === 'hacktoberfest-accepted';
                });
                
                const qualifies = isMerged && isInOctober2025 && isHacktoberfest;
                
                if (qualifies) {
                  console.log(`✅ Qualifying PR: #${pr.number} by @${pr.user.login} (merged: ${mergedDate.toISOString()})`);
                  console.log(`   Labels: ${pr.labels.map(l => l.name).join(', ')}`);
                }
                
                return qualifies;
              }).map(pr => ({
                user: pr.user.login,
                points: calculatePoints(pr.labels),
                repo: repo,
                prNumber: pr.number,
                prTitle: pr.title,
                labels: pr.labels,
                mergedAt: pr.merged_at
              }));

              console.log(`🎯 Qualifying Hacktoberfest PRs for ${repo}: ${hacktoberfestPRs.length}`);
              
              // Log each qualifying contributor
              const contributors = [...new Set(hacktoberfestPRs.map(pr => pr.user))];
              console.log(`👥 Contributors found: ${contributors.join(', ')}`);

              return hacktoberfestPRs;
            } catch (error) {
              console.error(`❌ Error fetching PRs for ${repo}: ${error.message}`);
              console.error(`Stack trace: ${error.stack}`);
              return [];
            }
          };

          const generateLeaderboard = async () => {
            try {
              console.log(`🏁 Starting leaderboard generation for ${REPOS.length} repositories...`);
              
              const allPRs = await Promise.all(REPOS.map(fetchRecentPRs));
              const flatPRs = allPRs.flat();

              console.log(`📊 Total qualifying PRs across all repos: ${flatPRs.length}`);
              
              if (flatPRs.length === 0) {
                console.log(`⚠️  No qualifying PRs found. Check date ranges and label criteria.`);
                return [];
              }

              const leaderboard = flatPRs.reduce((acc, pr) => {
                if (!acc[pr.user]) {
                  acc[pr.user] = { 
                    points: 0, 
                    prs: 0, 
                    userPRs: [] 
                  };
                }
                acc[pr.user].points += pr.points;
                acc[pr.user].prs += 1;
                acc[pr.user].userPRs.push(pr);
                return acc;
              }, {});

              console.log(`👥 Total contributors found: ${Object.keys(leaderboard).length}`);
              
              // Log each contributor's stats
              Object.entries(leaderboard).forEach(([username, data]) => {
                console.log(`   @${username}: ${data.points} points from ${data.prs} PRs`);
              });

              const sortedLeaderboard = Object.entries(leaderboard)
                .sort(([, a], [, b]) => {
                  // First sort by points
                  if (b.points !== a.points) return b.points - a.points;
                  
                  // If points are tied, sort by biggest PR size
                  const aBiggest = getBiggestPRSize(a.userPRs);
                  const bBiggest = getBiggestPRSize(b.userPRs);
                  const sizeOrder = { large: 3, medium: 2, small: 1 };
                  return sizeOrder[bBiggest] - sizeOrder[aBiggest];
                })
                .map(([username, data], index) => ({ 
                  rank: index + 1, 
                  username, 
                  points: data.points, 
                  prs: data.prs,
                  biggestPR: getBiggestPRSize(data.userPRs)
                }));

              console.log(`🏆 Leaderboard generated with ${sortedLeaderboard.length} ranked contributors`);
              
              // Log top 10 for debugging
              console.log(`🥇 Top 10 Contributors:`);
              sortedLeaderboard.slice(0, 10).forEach(entry => {
                console.log(`   ${entry.rank}. @${entry.username} - ${entry.points} points (${entry.prs} PRs, biggest: ${entry.biggestPR})`);
              });

              return sortedLeaderboard;
            } catch (error) {
              console.error(`❌ Error generating leaderboard: ${error.message}`);
              console.error(`Stack trace: ${error.stack}`);
              return [];
            }
          };

          const updateIssue = async (leaderboardData) => {
            const getRankEmoji = (rank) => {
              if (rank <= 3) return '⭐⭐⭐';
              if (rank <= 10) return '⭐';
              return '';
            };

            const issueBody = `# 🏆 Hacktoberfest 2025 Goose Leaderboard 🏆\n` +
              `Hello, lovely contributors! As Hacktoberfest 2025 and the crisp Fall breeze refreshes us, we wanted to make the contribution process extra fun. Check our live leaderboard below to see who our top contributors are this year in real-time. Not only does this recognize your efforts, it also brings an amplified competitive vibe with each contribution.\n\n` +
              `### 🌟 **Current Rankings:**\n\n` +
              `| Rank | Contributor | Points | PRs | Biggest PR to Date |\n` +
              `|------|-------------|--------|-----|--------------------|\n` +
              `${leaderboardData.map(entry => '| ' + entry.rank + ' ' + getRankEmoji(entry.rank) + ' | @' + entry.username + ' | ' + entry.points + ' | ' + entry.prs + ' | ' + entry.biggestPR + ' |').join('\\n')}\n\n` +
              `### 📜 How It Works:\n` +
              `The top 20 contributors will earn the first ever goose swag from the swag shop along with LLM credits! To earn your place in the leaderboard, we have created a points system that is explained below. As you complete a task by successfully merging a PR, you will automatically be granted a certain # of points.\n\n` +
              `#### 💯 Point System\n` +
              `| Weight | Points Awarded | Description |\n` +
              `|---------|-------------|-------------|\n` +
              `| 🐭 **Small** | 5 points | For smaller tasks that take limited time to complete and/or don't require any product knowledge. |\n` +
              `| 🐰 **Medium** | 10 points | For average tasks that take additional time to complete and/or require some product knowledge. |\n` +
              `| 🐂 **Large** | 15 points | For heavy tasks that takes lots of time to complete and/or possibly require deep product knowledge. |\n\n` +
              `#### 🎁 Rewards\n` +
              `- Made it to the **top 5**? Our Top 5 Contributors with the most points will be awarded $100 gift cards to our brand new goose swag shop and $100 of LLM credits!\n` +
              `- Reached the top **6-10**? Our Top 6-10 Contributors with the most points will be awarded $50 gift cards to our brand new goose swag shop and $50 of LLM credits!\n` +
              `- Landed in the top **11-20**? Our Top 11-20 Contributors with the most points will be awarded $25 of LLM credits! Keep an eye on your progress to make sure you're one step ahead!\n\n` +
              `### FAQ\n` +
              `- **Frequency of Updates:** The leaderboard will be updated every hour.\n` +
              `- **Criteria:** Rankings are based on how many points you earn across all approved PRs in the goose repo. To ensure your PRs are successfully merged:\n` +
              `  - Ensure your contributions are aligned with our project's Code of Conduct.\n` +
              `  - Refer to the goose repo's Contributing Guide.\n` +
              `- **Tie-Breakers:** In the event of a tie in total points, the contributor with the highest value single contribution (large > medium > small) will be ranked higher.\n\n\n` +
              `### 🚀 Get Featured:\n` +
              `Want to see your name climbing our ranks?\n\n` +
              `Explore our issues with the labels \`good-first-issue\` , \`no-code\` and \`hacktoberfest\` in the goose repo' Project Hub:\n\n` +
              `- **goose**\n` +
              `  - Hacktoberfest Project Hub\n` +
              `  - Contributing Guide\n\n\n` +
              `Excited to see everyone's hard work. Thank you so much for your invaluable contributions, and let the fun competition begin!\n\n` +
              `Last updated: ${new Date().toUTCString()}`;

            try {
              await github.rest.issues.update({
                owner,
                repo,
                issue_number: issueNumber,
                body: issueBody
              });

              console.log("Issue updated successfully!");
            } catch (error) {
              throw new Error(`Failed to update issue: ${error.message}`);
            }
          };

          // Main execution
          console.log(`🚀 Starting Hacktoberfest 2025 leaderboard update...`);
          console.log(`📋 Configuration:`);
          console.log(`   - Repositories: ${REPOS.join(', ')}`);
          console.log(`   - Issue number: ${issueNumber}`);
          console.log(`   - Date range: October 1-31, 2025`);
          console.log(`   - Point values: Small=${POINT_VALUES.small}, Medium=${POINT_VALUES.medium}, Large=${POINT_VALUES.large}`);
          
          try {
            const leaderboardData = await generateLeaderboard();
            
            if (leaderboardData.length > 0) {
              console.log(`✅ Updating issue with ${leaderboardData.length} contributors...`);
              await updateIssue(leaderboardData);
              console.log(`🎉 Leaderboard update completed successfully!`);
            } else {
              console.log(`⚠️  No leaderboard data to update. Creating empty leaderboard message...`);
              const emptyIssueBody = `# 🏆 Hacktoberfest 2025 Goose Leaderboard 🏆\n` +
                `Hello, lovely contributors! As Hacktoberfest 2025 and the crisp Fall breeze refreshes us, we wanted to make the contribution process extra fun. Check our live leaderboard below to see who our top contributors are this year in real-time. Not only does this recognize everyone's efforts, it also brings an amplified competitive vibe with each contribution.\n\n` +
                `### 🌟 **Current Rankings:**\n\n` +
                `| Rank | Contributor | Points | PRs | Biggest PR to Date |\n` +
                `|------|-------------|--------|-----|--------------------|\n` +
                `| | | | | |\n\n` +
                `**No qualifying PRs found for October 2025 at this time.**\n\n` +
                `**Debug Info:**\n` +
                `- Date range: October 1-31, 2025\n` +
                `- Repositories checked: ${REPOS.join(', ')}\n` +
                `- Qualifying labels: hacktoberfest, hacktoberfest-accepted\n` +
                `- Only merged PRs are counted\n\n` +
                `Check back soon as more contributions are made!\n\n` +
                `Last updated: ${new Date().toUTCString()}`;
              
              await github.rest.issues.update({
                owner,
                repo,
                issue_number: issueNumber,
                body: emptyIssueBody
              });
              console.log(`📝 Updated issue with empty leaderboard message and debug info.`);
            }
          } catch (error) {
            console.error(`💥 Fatal error during leaderboard update: ${error.message}`);
            console.error(`Stack trace: ${error.stack}`);
            
            // Try to update the issue with error information
            try {
              const errorIssueBody = `# 🏆 Hacktoberfest 2025 Goose Leaderboard 🏆\n\n` +
                `⚠️ **Error updating leaderboard**\n\n` +
                `There was an error updating the leaderboard. Please check the workflow logs for details.\n\n` +
                `**Error:** ${error.message}\n\n` +
                `**Time:** ${new Date().toUTCString()}\n\n` +
                `The development team has been notified and will fix this issue soon.`;
              
              await github.rest.issues.update({
                owner,
                repo,
                issue_number: issueNumber,
                body: errorIssueBody
              });
              console.log(`📝 Updated issue with error message.`);
            } catch (updateError) {
              console.error(`💥 Failed to update issue with error message: ${updateError.message}`);
            }
            
            throw error; // Re-throw to fail the workflow
          }
