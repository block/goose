version: 1.0.0
title: Test Coverage Analyzer
description: Analyze test coverage gaps in your codebase and get actionable recommendations on where to add tests for maximum impact
author:
  contact: ARYPROGRAMMER

activities:
  - Run test coverage analysis on codebase
  - Identify critical untested code paths
  - Prioritize files and functions needing tests
  - Generate specific test case recommendations
  - Track coverage improvements over time

prompt: |
  Analyze test coverage for {{ target_path }} with {{ coverage_tool }} and provide actionable recommendations.
  
  Focus on:
  - Critical business logic without tests
  - High-complexity functions with low coverage
  - Recent changes that lack test coverage
  - Edge cases and error handling paths
  
  Generate a prioritized list of files to test based on criticality and complexity.

instructions: |
  Perform comprehensive test coverage analysis and generate actionable testing recommendations.
  
  Your workflow:
  
  1. **Check Memory for Previous Coverage Data**
     - Retrieve baseline coverage metrics if available
     - Load previously identified critical gaps
     - This helps track improvements and avoid redundant analysis
  
  2. **Detect Test Framework and Coverage Tool**
     - Scan project for test configuration (package.json, pytest.ini, Cargo.toml, go.mod)
     - Identify test framework: Jest, Pytest, Go test, Cargo test, etc.
     - Identify coverage tool based on {{ coverage_tool }} parameter or auto-detect
  
  3. **Run Coverage Analysis**
     - Execute coverage command for the detected framework
     - Examples:
       * Jest: `npm test -- --coverage`
       * Pytest: `pytest --cov={{ target_path }} --cov-report=term --cov-report=json`
       * Go: `go test -coverprofile=coverage.out {{ target_path }}`
       * Rust: `cargo tarpaulin --out Json`
     - Parse coverage report (JSON/XML/terminal output)
  
  4. **Analyze Coverage Gaps**
     - Identify files with <{{ min_coverage }}% coverage
     - Find untested functions in critical business logic paths
     - Detect high-complexity functions (cyclomatic complexity >10) with low coverage
     - Highlight error handling and edge cases without tests
     - Calculate coverage by module/package
     - Exclude patterns: {{ exclude_patterns }}
  
  5. **Prioritize Testing Recommendations**
     Create a prioritized list based on:
     - **Critical Priority**: Files with 0% coverage in core business logic
     - **High Priority**: Functions with complexity >10 and coverage <50%
     - **Medium Priority**: Recently modified files (last 7 days) with <80% coverage
     - **Low Priority**: Utility functions with <90% coverage
     
     For each priority item, include:
     * File path and line numbers
     * Current coverage percentage
     * Complexity score
     * Specific test scenarios to implement
  
  6. **Generate Test Case Suggestions**
     For top 5 priority items, provide:
     - Concrete test case descriptions
     - Example test structure in the project's test framework
     - Mock/fixture requirements
     - Edge cases to cover
  
  7. **Create Coverage Summary Report**
     Generate `test-coverage-report.md` in the current working directory with:
     
     ```markdown
     # Test Coverage Analysis Report
     
     ## Summary
     - Overall Coverage: X%
     - Lines Covered: X/Y
     - Branches Covered: X/Y
     - Functions Covered: X/Y
     
     ## Coverage by Module
     | Module | Coverage | Priority |
     |--------|----------|----------|
     | ... | ... | ... |
     
     ## Critical Gaps (Priority: Critical)
     ### File: path/to/file.ext (0% coverage)
     - **Function**: `functionName` (Lines X-Y)
     - **Complexity**: High (score: N)
     - **Why Critical**: Core business logic for payment processing
     - **Recommended Tests**:
       1. Test happy path with valid inputs
       2. Test error handling for invalid data
       3. Test boundary conditions
     
     ## High Priority Gaps
     ...
     
     ## Improvement Tracking
     - Previous Coverage: [Retrieved from memory if available]
     - Current Coverage: X%
     - Change: +/- Y%
     ```
  
  8. **Store Summary Metrics in Memory**
     Save ONLY these lightweight metrics for future comparison:
     - Current overall coverage percentage (key: "coverage_percentage")
     - Date of analysis (key: "coverage_date")
     - Top 3 critical files still needing tests (key: "critical_files")
     
     DO NOT store full reports or detailed coverage data in memory.
     All detailed data should be in the markdown file only.
  
  9. **Present Findings**
     Display:
     - Quick summary with overall coverage
     - Top 5 priority files to test
     - Path to full report file (test-coverage-report.md in current directory)
     - Quick win suggestions (easiest high-impact tests to add)
     
     **IMPORTANT**: Confirm the report file was created and show its full path

parameters:
  - key: target_path
    input_type: string
    requirement: optional
    default: "."
    description: "Path to analyze (directory or specific file). Use '.' for entire project"
  
  - key: coverage_tool
    input_type: string
    requirement: optional
    default: "auto"
    description: "Coverage tool to use: 'auto' (detect), 'jest', 'pytest', 'go', 'cargo', 'nyc', 'coverage.py'"
  
  - key: min_coverage
    input_type: string
    requirement: optional
    default: "80"
    description: "Minimum coverage threshold percentage (files below this are flagged)"
  
  - key: exclude_patterns
    input_type: string
    requirement: optional
    default: "test,spec,mock,__pycache__,node_modules,vendor"
    description: "Comma-separated patterns to exclude from analysis"

extensions:
  - type: builtin
    name: developer
    display_name: Developer
    timeout: 300
    bundled: true
    description: For running tests, analyzing code complexity, and generating reports
  
  - type: builtin
    name: memory
    display_name: Memory
    timeout: 300
    bundled: true
    description: For storing lightweight coverage baselines and tracking improvements over time
