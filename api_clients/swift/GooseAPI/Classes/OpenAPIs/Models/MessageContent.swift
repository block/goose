//
// MessageContent.swift
//
// Generated by openapi-generator
// https://openapi-generator.tech
//

import Foundation
#if canImport(AnyCodable)
import AnyCodable
#endif

/** Content passed inside a message, which can be both simple content and tool content */
public enum MessageContent: Codable, JSONEncodable, Hashable {
    case typeMessageContentOneOf(MessageContentOneOf)
    case typeMessageContentOneOf1(MessageContentOneOf1)
    case typeMessageContentOneOf2(MessageContentOneOf2)
    case typeMessageContentOneOf3(MessageContentOneOf3)
    case typeMessageContentOneOf4(MessageContentOneOf4)
    case typeMessageContentOneOf5(MessageContentOneOf5)
    case typeMessageContentOneOf6(MessageContentOneOf6)
    case typeMessageContentOneOf7(MessageContentOneOf7)
    case typeMessageContentOneOf8(MessageContentOneOf8)
    case typeMessageContentOneOf9(MessageContentOneOf9)

    public func encode(to encoder: Encoder) throws {
        var container = encoder.singleValueContainer()
        switch self {
        case .typeMessageContentOneOf(let value):
            try container.encode(value)
        case .typeMessageContentOneOf1(let value):
            try container.encode(value)
        case .typeMessageContentOneOf2(let value):
            try container.encode(value)
        case .typeMessageContentOneOf3(let value):
            try container.encode(value)
        case .typeMessageContentOneOf4(let value):
            try container.encode(value)
        case .typeMessageContentOneOf5(let value):
            try container.encode(value)
        case .typeMessageContentOneOf6(let value):
            try container.encode(value)
        case .typeMessageContentOneOf7(let value):
            try container.encode(value)
        case .typeMessageContentOneOf8(let value):
            try container.encode(value)
        case .typeMessageContentOneOf9(let value):
            try container.encode(value)
        }
    }

    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        if let value = try? container.decode(MessageContentOneOf.self) {
            self = .typeMessageContentOneOf(value)
        } else if let value = try? container.decode(MessageContentOneOf1.self) {
            self = .typeMessageContentOneOf1(value)
        } else if let value = try? container.decode(MessageContentOneOf2.self) {
            self = .typeMessageContentOneOf2(value)
        } else if let value = try? container.decode(MessageContentOneOf3.self) {
            self = .typeMessageContentOneOf3(value)
        } else if let value = try? container.decode(MessageContentOneOf4.self) {
            self = .typeMessageContentOneOf4(value)
        } else if let value = try? container.decode(MessageContentOneOf5.self) {
            self = .typeMessageContentOneOf5(value)
        } else if let value = try? container.decode(MessageContentOneOf6.self) {
            self = .typeMessageContentOneOf6(value)
        } else if let value = try? container.decode(MessageContentOneOf7.self) {
            self = .typeMessageContentOneOf7(value)
        } else if let value = try? container.decode(MessageContentOneOf8.self) {
            self = .typeMessageContentOneOf8(value)
        } else if let value = try? container.decode(MessageContentOneOf9.self) {
            self = .typeMessageContentOneOf9(value)
        } else {
            throw DecodingError.typeMismatch(Self.Type.self, .init(codingPath: decoder.codingPath, debugDescription: "Unable to decode instance of MessageContent"))
        }
    }
}


@available(iOS 13, tvOS 13, watchOS 6, macOS 10.15, *)
extension MessageContent: Identifiable {}
