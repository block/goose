//
// ModelInfo.swift
//
// Generated by openapi-generator
// https://openapi-generator.tech
//

import Foundation
#if canImport(AnyCodable)
import AnyCodable
#endif

/** Information about a model&#39;s capabilities */
public struct ModelInfo: Codable, JSONEncodable, Hashable {

    public static let contextLimitRule = NumericRule<Int>(minimum: 0, exclusiveMinimum: false, maximum: nil, exclusiveMaximum: false, multipleOf: nil)
    /** The maximum context length this model supports */
    public var contextLimit: Int
    /** Currency for the costs (default: \"$\") */
    public var currency: String?
    /** Cost per token for input (optional) */
    public var inputTokenCost: Double?
    /** The name of the model */
    public var name: String
    /** Cost per token for output (optional) */
    public var outputTokenCost: Double?
    /** Whether this model supports cache control */
    public var supportsCacheControl: Bool?

    public init(contextLimit: Int, currency: String? = nil, inputTokenCost: Double? = nil, name: String, outputTokenCost: Double? = nil, supportsCacheControl: Bool? = nil) {
        self.contextLimit = contextLimit
        self.currency = currency
        self.inputTokenCost = inputTokenCost
        self.name = name
        self.outputTokenCost = outputTokenCost
        self.supportsCacheControl = supportsCacheControl
    }

    public enum CodingKeys: String, CodingKey, CaseIterable {
        case contextLimit = "context_limit"
        case currency
        case inputTokenCost = "input_token_cost"
        case name
        case outputTokenCost = "output_token_cost"
        case supportsCacheControl = "supports_cache_control"
    }

    // Encodable protocol methods

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        try container.encode(contextLimit, forKey: .contextLimit)
        try container.encodeIfPresent(currency, forKey: .currency)
        try container.encodeIfPresent(inputTokenCost, forKey: .inputTokenCost)
        try container.encode(name, forKey: .name)
        try container.encodeIfPresent(outputTokenCost, forKey: .outputTokenCost)
        try container.encodeIfPresent(supportsCacheControl, forKey: .supportsCacheControl)
    }
}

