use super::extension::PlatformExtensionContext;
use super::mcp_client::McpClientTrait;
use async_trait::async_trait;
use rmcp::model::{
    CallToolResult, Content, Implementation, InitializeResult, ListToolsResult, ServerCapabilities,
    Tool, ToolAnnotations,
};
use schemars::{schema_for, JsonSchema};
use serde::Deserialize;
use serde_json::Value as JsonValue;
use tokio_util::sync::CancellationToken;

type Error = rmcp::ServiceError;
type JsonObject = serde_json::Map<String, JsonValue>;

pub const EXTENSION_NAME: &str = "genui";

/// The catalog prompt generated by @json-render/core catalog.prompt()
/// This defines the full JSONL streaming format, all available components,
/// their props, state management, events, visibility, and rendering rules.
static CATALOG_PROMPT: &str = include_str!("genui_catalog_prompt.txt");

/// Known component names for validation.
const KNOWN_COMPONENTS: &[&str] = &[
    "Card",
    "Stack",
    "Grid",
    "Separator",
    "Tabs",
    "Accordion",
    "Collapsible",
    "Dialog",
    "Drawer",
    "Popover",
    "Tooltip",
    "DropdownMenu",
    "Heading",
    "Text",
    "Image",
    "Avatar",
    "Badge",
    "Alert",
    "Table",
    "Carousel",
    "Progress",
    "Skeleton",
    "Spinner",
    "Input",
    "Textarea",
    "Select",
    "Checkbox",
    "Switch",
    "Slider",
    "Button",
    "Toggle",
    "Link",
    "Pagination",
    "Chart",
];

#[derive(Debug, Deserialize, JsonSchema)]
#[allow(dead_code)]
struct RenderParams {
    /// The JSON spec to render as visual components.
    /// Can be either a nested tree format: { "root": { "type": "Card", ... } }
    /// or JSONL patches: one JSON patch per line for streaming.
    spec: JsonValue,
}

#[derive(Debug, Deserialize, JsonSchema)]
struct ComponentsParams {}

pub struct GenUiClient {
    info: InitializeResult,
    #[allow(dead_code)]
    context: PlatformExtensionContext,
}

impl GenUiClient {
    pub fn new(context: PlatformExtensionContext) -> anyhow::Result<Self> {
        let instructions = format!(
            "Use this extension to render visual UI components inline in chat messages.\n\
            \n\
            ## When to use genui vs apps\n\
            - **genui**: \"Show me\", \"visualize\", \"display as table/chart/card\" → inline visual\n\
            - **apps**: \"Build me an app\", \"create a tool I can reuse\" → standalone window\n\
            \n\
            ## IMPORTANT: How to render visuals\n\
            To show visual components to the user, include a ```json-render fenced code block \
            DIRECTLY in your text response. Do NOT rely on the genui__render tool result being \
            visible — tool results are collapsed. Always copy the spec into your response text.\n\
            \n\
            Example workflow:\n\
            1. Gather data using developer tools\n\
            2. Call `genui__render` to VALIDATE your spec (optional)\n\
            3. Include the ```json-render code block in your response text\n\
            \n\
            The user sees your text response, so the code block MUST be there.\n\
            \n\
            ## Component Catalog\n\
            {CATALOG_PROMPT}\n"
        );

        Ok(Self {
            info: InitializeResult {
                protocol_version: Default::default(),
                capabilities: ServerCapabilities {
                    tools: Some(Default::default()),
                    ..Default::default()
                },
                server_info: Implementation {
                    name: "genui".to_string(),
                    version: env!("CARGO_PKG_VERSION").to_string(),
                    ..Default::default()
                },
                instructions: Some(instructions),
            },
            context,
        })
    }

    fn validate_component_names(value: &JsonValue) -> Vec<String> {
        let mut errors = Vec::new();
        Self::validate_recursive(value, &mut errors);
        errors
    }

    fn validate_recursive(value: &JsonValue, errors: &mut Vec<String>) {
        if let Some(obj) = value.as_object() {
            if let Some(type_val) = obj.get("type").and_then(|v| v.as_str()) {
                if !KNOWN_COMPONENTS.contains(&type_val) {
                    errors.push(format!("Unknown component: '{type_val}'"));
                }
            }
            if let Some(children) = obj.get("children").and_then(|v| v.as_array()) {
                for child in children {
                    Self::validate_recursive(child, errors);
                }
            }
            // Validate element values in flat format
            if let Some(elements) = obj.get("elements").and_then(|v| v.as_object()) {
                for (_, element) in elements {
                    Self::validate_recursive(element, errors);
                }
            }
        }
    }

    fn handle_render(&self, arguments: Option<JsonObject>) -> Result<Vec<Content>, String> {
        let args = arguments.ok_or("Missing arguments")?;
        let spec = args.get("spec").ok_or("Missing 'spec' argument")?;

        // Validate component names
        let validation_errors = Self::validate_component_names(spec);
        if !validation_errors.is_empty() {
            return Err(format!(
                "Invalid components: {}. Available: Card, Stack, Grid, Heading, Text, Badge, \
                 Alert, Table, Progress, Button, Tabs, etc.",
                validation_errors.join(", ")
            ));
        }

        let pretty = serde_json::to_string_pretty(spec)
            .map_err(|e| format!("Failed to serialize spec: {e}"))?;

        Ok(vec![Content::text(format!(
            "Visual component rendered successfully.\n\n```json-render\n{pretty}\n```"
        ))])
    }

    fn handle_components(&self) -> Vec<Content> {
        // Return the full catalog prompt which includes all components, props, and usage
        vec![Content::text(format!(
            "# Available UI Components\n\n\
             Use these components with `genui__render` or in ```json-render code blocks.\n\n\
             {CATALOG_PROMPT}"
        ))]
    }

    fn tools() -> Vec<Tool> {
        let render_schema = serde_json::to_value(schema_for!(RenderParams))
            .expect("Failed to serialize RenderParams schema");
        let components_schema = serde_json::to_value(schema_for!(ComponentsParams))
            .expect("Failed to serialize ComponentsParams schema");

        vec![
            Tool::new(
                "render".to_string(),
                "Render visual UI components inline in chat. Pass a JSON spec with a root \
                 element tree. Components are validated and rendered as interactive Radix UI \
                 components. Use for tables, cards, dashboards, data visualizations, diagrams. \
                 Quick rule: 'Show/visualize/display' → use this tool."
                    .to_string(),
                render_schema.as_object().unwrap().clone(),
            )
            .annotate(ToolAnnotations {
                title: Some("Render Visual Component".to_string()),
                read_only_hint: Some(true),
                destructive_hint: Some(false),
                idempotent_hint: Some(true),
                open_world_hint: Some(false),
            }),
            Tool::new(
                "components".to_string(),
                "List all available UI components with their props, events, and usage examples."
                    .to_string(),
                components_schema.as_object().unwrap().clone(),
            )
            .annotate(ToolAnnotations {
                title: Some("List Available Components".to_string()),
                read_only_hint: Some(true),
                destructive_hint: Some(false),
                idempotent_hint: Some(true),
                open_world_hint: Some(false),
            }),
        ]
    }
}

#[async_trait]
impl McpClientTrait for GenUiClient {
    async fn list_tools(
        &self,
        _session_id: &str,
        _next_cursor: Option<String>,
        _cancel_token: CancellationToken,
    ) -> Result<ListToolsResult, Error> {
        Ok(ListToolsResult {
            tools: Self::tools(),
            next_cursor: None,
            meta: None,
        })
    }

    async fn call_tool(
        &self,
        _session_id: &str,
        name: &str,
        arguments: Option<JsonObject>,
        _working_dir: Option<&str>,
        _cancel_token: CancellationToken,
    ) -> Result<CallToolResult, Error> {
        match name {
            "render" => match self.handle_render(arguments) {
                Ok(content) => Ok(CallToolResult::success(content)),
                Err(e) => Ok(CallToolResult::error(vec![Content::text(format!(
                    "Error: {e}"
                ))])),
            },
            "components" => Ok(CallToolResult::success(self.handle_components())),
            _ => Ok(CallToolResult::error(vec![Content::text(format!(
                "Unknown tool: {name}"
            ))])),
        }
    }

    async fn get_moim(&self, _session_id: &str) -> Option<String> {
        Some(format!(
            "{}\n\n\
            CRITICAL — How to show visual components to the user:\n\
            You MUST include the ```json-render fenced code block DIRECTLY in your text response.\n\
            Tool results (including genui__render results) are collapsed and hidden from the user.\n\
            The ONLY way the user sees rendered components is if you write the ```json-render code block\n\
            in your response text. After gathering data, output the spec as a ```json-render code block.\n\n\
            VISUAL QUALITY RULES:\n\
            1. Wrap root in Card(maxWidth \"lg\") — never stretch full width.\n\
            2. Use h3 for section titles, h4 for sub-sections — never h1 or h2.\n\
            3. Numbers go in StatCard or Heading inside Card — never in Badge.\n\
            4. Charts max height 180px, max 2 per dashboard, place side-by-side in Grid columns=2.\n\
            5. Tables max 7 rows, sorted by value descending, right-align numbers.\n\
            6. Text must be variant \"default\" on backgrounds — never \"muted\" for primary content.\n\
            7. Every chart and table must be wrapped in its own Card.\n\
            8. Use Separator between major sections.\n\
            9. Dashboard must fit in 1-1.5 viewport heights (700-1000px total).\n\
            10. Never open with an Alert restating the title — use Heading directly.",
            CATALOG_PROMPT
        ))
    }

    fn get_info(&self) -> Option<&InitializeResult> {
        Some(&self.info)
    }
}
