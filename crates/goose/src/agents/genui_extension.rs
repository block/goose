use super::extension::PlatformExtensionContext;
use super::mcp_client::McpClientTrait;
use async_trait::async_trait;
use rmcp::model::{
    CallToolResult, Content, Implementation, InitializeResult, ListToolsResult, ServerCapabilities,
    Tool, ToolAnnotations,
};
use schemars::{schema_for, JsonSchema};
use serde::Deserialize;
use serde_json::Value as JsonValue;
use tokio_util::sync::CancellationToken;

type Error = rmcp::ServiceError;
type JsonObject = serde_json::Map<String, JsonValue>;

pub const EXTENSION_NAME: &str = "genui";

/// The catalog prompt generated by @json-render/core catalog.prompt()
/// This defines the full JSONL streaming format, all available components,
/// their props, state management, events, visibility, and rendering rules.
static CATALOG_PROMPT: &str = include_str!("genui_catalog_prompt.txt");

/// Known component names for validation.
const KNOWN_COMPONENTS: &[&str] = &[
    "Card",
    "Stack",
    "Grid",
    "Separator",
    "Tabs",
    "Accordion",
    "Collapsible",
    "Dialog",
    "Drawer",
    "Popover",
    "Tooltip",
    "DropdownMenu",
    "Heading",
    "Text",
    "Image",
    "Avatar",
    "Badge",
    "Alert",
    "StatCard",
    "Table",
    "DataTable",
    "Carousel",
    "Progress",
    "Skeleton",
    "Spinner",
    "Input",
    "Textarea",
    "Select",
    "Checkbox",
    "Switch",
    "Slider",
    "Button",
    "Toggle",
    "Link",
    "Pagination",
    "Chart",
    "CardGrid",
];

#[derive(Debug, Deserialize, JsonSchema)]
#[allow(dead_code)]
struct RenderParams {
    /// The JSON spec to render as visual components.
    /// Can be either a nested tree format: { "root": { "type": "Card", ... } }
    /// or JSONL patches: one JSON patch per line for streaming.
    spec: JsonValue,
}

#[derive(Debug, Deserialize, JsonSchema)]
struct ComponentsParams {}

pub struct GenUiClient {
    info: InitializeResult,
    #[allow(dead_code)]
    context: PlatformExtensionContext,
}

impl GenUiClient {
    pub fn new(context: PlatformExtensionContext) -> anyhow::Result<Self> {
        let instructions = format!(
            "Use this extension to render visual UI components inline in chat messages.\n\
            \n\
            ## When to use genui vs apps\n\
            - **genui**: \"Show me\", \"visualize\", \"display as table/chart/card\" → inline visual\n\
            - **apps**: \"Build me an app\", \"create a tool I can reuse\" → standalone window\n\
            \n\
            ## IMPORTANT: How to render visuals\n\
            To show visual components to the user, include the json-render JSONL spec directly in \
            your text response. Do NOT rely on the genui__render tool result being visible — tool \
            results are collapsed.\n\
            \n\
            Markdown fences are optional. If you use a fence, it MUST be ```json-render.\n\
            \n\
            Example workflow:
            1. Gather data using developer tools
            2. Call `genui__render` to VALIDATE your spec (required)
            3. Output the JSONL spec in your response (fenced or unfenced)
            \n\
            ## Component Catalog\n\
            {CATALOG_PROMPT}\n"
        );

        Ok(Self {
            info: InitializeResult {
                protocol_version: Default::default(),
                capabilities: ServerCapabilities {
                    tools: Some(Default::default()),
                    ..Default::default()
                },
                server_info: Implementation {
                    name: "genui".to_string(),
                    version: env!("CARGO_PKG_VERSION").to_string(),
                    ..Default::default()
                },
                instructions: Some(instructions),
            },
            context,
        })
    }

    fn validate_spec(value: &JsonValue) -> Vec<String> {
        let mut errors = Vec::new();

        let state = value
            .as_object()
            .and_then(|o| o.get("state"))
            .filter(|v| !v.is_null());

        Self::validate_root_card(value, &mut errors);
        Self::validate_recursive(value, state, &mut errors);

        errors
    }

    fn validate_root_card(value: &JsonValue, errors: &mut Vec<String>) {
        let Some(obj) = value.as_object() else {
            return;
        };

        let root_val = if let Some(root) = obj.get("root") {
            if root.is_object() {
                Some(root)
            } else {
                let root_id = root.as_str();
                let elements = obj.get("elements").and_then(|v| v.as_object());
                root_id.and_then(|id| elements.and_then(|m| m.get(id)))
            }
        } else {
            None
        };

        let Some(root_val) = root_val else {
            return;
        };
        let Some(root_obj) = root_val.as_object() else {
            return;
        };

        let root_type = root_obj.get("type").and_then(|v| v.as_str());
        if root_type != Some("Card") {
            errors.push("Root element must be a Card".to_string());
            return;
        }

        let Some(props) = root_obj.get("props").and_then(|v| v.as_object()) else {
            errors.push(
                "Root Card must set props.maxWidth=\"full\" and props.centered=false".to_string(),
            );
            return;
        };

        match props.get("maxWidth").and_then(|v| v.as_str()) {
            Some("full") => {}
            _ => errors.push("Root Card must set props.maxWidth=\"full\"".to_string()),
        }

        match props.get("centered").and_then(|v| v.as_bool()) {
            Some(false) => {}
            _ => errors.push("Root Card must set props.centered=false".to_string()),
        }
    }

    fn validate_recursive(value: &JsonValue, state: Option<&JsonValue>, errors: &mut Vec<String>) {
        let Some(obj) = value.as_object() else {
            return;
        };

        // Support specs that wrap the UI tree in a top-level `root` field (nested)
        // or a flat spec container (`root`: string, plus `elements`).
        if obj.get("type").is_none() {
            if let Some(root) = obj.get("root") {
                Self::validate_recursive(root, state, errors);
            }
            if let Some(elements) = obj.get("elements") {
                Self::validate_recursive(elements, state, errors);
            }

            // If this object isn't a known wrapper but looks like an `elements` map, walk values.
            if obj.get("root").is_none() && obj.get("elements").is_none() {
                for (_, v) in obj {
                    Self::validate_recursive(v, state, errors);
                }
            }

            return;
        }

        let Some(type_val) = obj.get("type").and_then(|v| v.as_str()) else {
            return;
        };

        if !KNOWN_COMPONENTS.contains(&type_val) {
            errors.push(format!("Unknown component: '{type_val}'"));
        }

        fn state_pointer<'a>(
            state: Option<&'a JsonValue>,
            binding: &JsonValue,
        ) -> Option<&'a JsonValue> {
            let ptr = binding
                .as_object()
                .and_then(|o| o.get("$state"))
                .and_then(|v| v.as_str())?;
            state.and_then(|s| s.pointer(ptr))
        }

        if let Some(props) = obj.get("props").and_then(|v| v.as_object()) {
            match type_val {
                "Grid" => {
                    if let Some(n) = props.get("columns").and_then(|v| v.as_u64()) {
                        if n > 2 {
                            errors.push("Grid.columns must be <= 2".to_string());
                        }
                    }
                }
                "Table" | "DataTable" => {
                    if let Some(rows) = props.get("rows") {
                        if let Some(arr) = rows.as_array() {
                            if arr.is_empty() {
                                errors.push(format!("{type_val}.rows must not be empty"));
                            }
                        } else if let Some(v) = state_pointer(state, rows) {
                            match v.as_array() {
                                Some(arr) if arr.is_empty() => errors.push(format!(
                                    "{type_val}.rows state binding must not resolve to an empty array"
                                )),
                                Some(_) => {}
                                None => errors.push(format!(
                                    "{type_val}.rows state binding must resolve to an array"
                                )),
                            }
                        } else if rows.as_object().and_then(|o| o.get("$state")).is_some() {
                            errors.push(format!(
                                "{type_val}.rows uses a $state binding but no matching state value was found"
                            ));
                        }
                    }
                }
                "Chart" => {
                    if let Some(data) = props.get("data") {
                        if let Some(arr) = data.as_array() {
                            if arr.is_empty() {
                                errors.push("Chart.data must not be empty".to_string());
                            }
                        } else if let Some(v) = state_pointer(state, data) {
                            match v.as_array() {
                                Some(arr) if arr.is_empty() => errors.push(
                                    "Chart.data state binding must not resolve to an empty array"
                                        .to_string(),
                                ),
                                Some(_) => {}
                                None => errors.push(
                                    "Chart.data state binding must resolve to an array".to_string(),
                                ),
                            }
                        } else if data.as_object().and_then(|o| o.get("$state")).is_some() {
                            errors.push(
                                "Chart.data uses a $state binding but no matching state value was found"
                                    .to_string(),
                            );
                        }
                    }
                }
                "StatCard" => {
                    let Some(value) = props.get("value") else {
                        errors.push("StatCard.value is required".to_string());
                        return;
                    };

                    match value {
                        JsonValue::String(s) if s.trim().is_empty() => {
                            errors.push("StatCard.value must not be empty".to_string())
                        }
                        JsonValue::Null => {
                            errors.push("StatCard.value must not be null".to_string())
                        }
                        v if v.as_object().and_then(|o| o.get("$state")).is_some() => {
                            if let Some(resolved) = state_pointer(state, v) {
                                if resolved.is_null() {
                                    errors.push(
                                        "StatCard.value state binding must not resolve to null"
                                            .to_string(),
                                    );
                                } else if let Some(s) = resolved.as_str() {
                                    if s.trim().is_empty() {
                                        errors.push(
                                            "StatCard.value state binding must not resolve to an empty string"
                                                .to_string(),
                                        );
                                    }
                                }
                            } else {
                                errors.push(
                                    "StatCard.value uses a $state binding but no matching state value was found"
                                        .to_string(),
                                );
                            }
                        }
                        _ => {}
                    }
                }
                _ => {}
            }
        }

        if let Some(children) = obj.get("children").and_then(|v| v.as_array()) {
            for child in children {
                Self::validate_recursive(child, state, errors);
            }
        }

        if let Some(elements) = obj.get("elements").and_then(|v| v.as_object()) {
            for (_, element) in elements {
                Self::validate_recursive(element, state, errors);
            }
        }
    }

    fn handle_render(&self, arguments: Option<JsonObject>) -> Result<Vec<Content>, String> {
        let args = arguments.ok_or("Missing arguments")?;
        let spec = args.get("spec").ok_or("Missing 'spec' argument")?;

        // Validate component names + basic quality rules
        let validation_errors = Self::validate_spec(spec);
        if !validation_errors.is_empty() {
            return Err(format!(
                "Invalid components: {}. Available: Card, Stack, Grid, Heading, Text, Badge, \
                 Alert, Table, DataTable, Progress, Button, Tabs, etc.",
                validation_errors.join(", ")
            ));
        }

        let pretty = serde_json::to_string_pretty(spec)
            .map_err(|e| format!("Failed to serialize spec: {e}"))?;

        Ok(vec![Content::text(format!(
            "Visual component rendered successfully.\n\n```json-render\n{pretty}\n```"
        ))])
    }

    fn handle_components(&self) -> Vec<Content> {
        // Return the full catalog prompt which includes all components, props, and usage
        vec![Content::text(format!(
            "# Available UI Components\n\n\
             Use these components with `genui__render` or in ```json-render code blocks.\n\n\
             {CATALOG_PROMPT}"
        ))]
    }

    fn tools() -> Vec<Tool> {
        let render_schema = serde_json::to_value(schema_for!(RenderParams))
            .expect("Failed to serialize RenderParams schema");
        let components_schema = serde_json::to_value(schema_for!(ComponentsParams))
            .expect("Failed to serialize ComponentsParams schema");

        vec![
            Tool::new(
                "render".to_string(),
                "Render visual UI components inline in chat. Pass a JSON spec with a root \
                 element tree. Components are validated and rendered as interactive Radix UI \
                 components. Use for tables, cards, dashboards, data visualizations, diagrams. \
                 Quick rule: 'Show/visualize/display' → use this tool."
                    .to_string(),
                render_schema.as_object().unwrap().clone(),
            )
            .annotate(ToolAnnotations {
                title: Some("Render Visual Component".to_string()),
                read_only_hint: Some(true),
                destructive_hint: Some(false),
                idempotent_hint: Some(true),
                open_world_hint: Some(false),
            }),
            Tool::new(
                "components".to_string(),
                "List all available UI components with their props, events, and usage examples."
                    .to_string(),
                components_schema.as_object().unwrap().clone(),
            )
            .annotate(ToolAnnotations {
                title: Some("List Available Components".to_string()),
                read_only_hint: Some(true),
                destructive_hint: Some(false),
                idempotent_hint: Some(true),
                open_world_hint: Some(false),
            }),
        ]
    }
}

#[async_trait]
impl McpClientTrait for GenUiClient {
    async fn list_tools(
        &self,
        _session_id: &str,
        _next_cursor: Option<String>,
        _cancel_token: CancellationToken,
    ) -> Result<ListToolsResult, Error> {
        Ok(ListToolsResult {
            tools: Self::tools(),
            next_cursor: None,
            meta: None,
        })
    }

    async fn call_tool(
        &self,
        _session_id: &str,
        name: &str,
        arguments: Option<JsonObject>,
        _working_dir: Option<&str>,
        _cancel_token: CancellationToken,
    ) -> Result<CallToolResult, Error> {
        match name {
            "render" => match self.handle_render(arguments) {
                Ok(content) => Ok(CallToolResult::success(content)),
                Err(e) => Ok(CallToolResult::error(vec![Content::text(format!(
                    "Error: {e}"
                ))])),
            },
            "components" => Ok(CallToolResult::success(self.handle_components())),
            _ => Ok(CallToolResult::error(vec![Content::text(format!(
                "Unknown tool: {name}"
            ))])),
        }
    }

    async fn get_moim(&self, _session_id: &str) -> Option<String> {
        Some(format!(
            "{}\n\n\
            CRITICAL — How to show visual components to the user:\n\
            Output the json-render JSONL spec DIRECTLY in your text response.\n\
            Tool results (including genui__render results) are collapsed and hidden from the user.\n\
            Markdown fences are optional; if you use a fence, it MUST be ```json-render.\n\n\
            VISUAL QUALITY RULES:\n\
            1. Wrap root in Card(maxWidth \"full\", centered=false) for chat — avoid narrow centered layouts.\n\
            2. Use h3 for section titles, h4 for sub-sections — never h1 or h2.\n\
            3. Numbers go in StatCard or Heading inside Card — never in Badge.\n\
            4. Charts max height 180px, max 2 per dashboard, place side-by-side in Grid columns=2.\n\
            5. Use DataTable for sortable rankings; Table for basic display. Keep max 7 rows and right-align numbers.\n\
            6. Text must be variant \"default\" on backgrounds — never \"muted\" for primary content.\n\
            7. Every chart and table must be wrapped in its own Card.\n\
            8. Use Separator between major sections.\n\
            9. Dashboard must fit in 1-1.5 viewport heights (700-1000px total).\n\
            10. Never open with an Alert restating the title — use Heading directly.",
            CATALOG_PROMPT
        ))
    }

    fn get_info(&self) -> Option<&InitializeResult> {
        Some(&self.info)
    }
}

#[cfg(test)]
mod drift_tests {
    use super::GenUiClient;

    use serde_json::Value as JsonValue;

    static GENUI_CATALOG_PROMPT: &str = include_str!("genui_catalog_prompt.txt");
    static JSON_RENDER_VISUAL_SKILL: &str =
        include_str!("builtin_skills/skills/json_render_visual.md");

    fn extract_json_render_fences(text: &str) -> Vec<String> {
        let mut blocks = Vec::new();
        let mut current: Vec<&str> = Vec::new();
        let mut in_block = false;

        for line in text.lines() {
            if !in_block {
                if line.trim_start().starts_with("```json-render") {
                    in_block = true;
                    current.clear();
                }
                continue;
            }

            if line.trim() == "```" {
                blocks.push(current.join("\n"));
                in_block = false;
                current.clear();
                continue;
            }

            current.push(line);
        }

        blocks
    }

    fn apply_jsonl_patch_lines(lines: &str) -> JsonValue {
        use json_patch::PatchOperation;

        let mut doc = JsonValue::Object(serde_json::Map::new());

        for line in lines.lines().map(str::trim).filter(|l| !l.is_empty()) {
            let op: PatchOperation = serde_json::from_str(line)
                .unwrap_or_else(|e| panic!("Invalid JSONL line: {line}\n{e}"));
            json_patch::patch(&mut doc, std::slice::from_ref(&op))
                .unwrap_or_else(|e| panic!("Failed to apply patch line: {line}\n{e}"));
        }

        doc
    }

    fn parse_spec(block: &str) -> JsonValue {
        // Heuristic: if every non-empty line parses as a patch op, treat as JSONL.
        let all_lines_patch_ops = block
            .lines()
            .map(str::trim)
            .filter(|l| !l.is_empty())
            .all(|line| serde_json::from_str::<json_patch::PatchOperation>(line).is_ok());

        if all_lines_patch_ops {
            apply_jsonl_patch_lines(block)
        } else {
            serde_json::from_str(block).expect("Nested json-render example must be valid JSON")
        }
    }

    fn assert_examples_validate(text: &str) {
        for block in extract_json_render_fences(text) {
            let spec = parse_spec(&block);
            let errors = GenUiClient::validate_spec(&spec);
            assert!(
                errors.is_empty(),
                "json-render example must satisfy validate_spec. Errors: {errors:?}\nSpec: {spec}"
            );
        }
    }

    #[test]
    fn genui_catalog_prompt_examples_validate() {
        assert_examples_validate(GENUI_CATALOG_PROMPT);
    }

    #[test]
    fn json_render_visual_skill_examples_validate() {
        assert_examples_validate(JSON_RENDER_VISUAL_SKILL);
    }
}
