<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Genuary Day 1 - One Color, One Shape</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        body {
            background: #0a0a0a;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            font-family: 'Courier New', monospace;
        }
        #canvas {
            border-radius: 4px;
            box-shadow: 0 0 60px rgba(255, 107, 107, 0.2);
        }
        .info {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            color: #ff6b6b;
            font-size: 12px;
            opacity: 0.7;
        }
    </style>
</head>
<body>
    <canvas id="canvas"></canvas>
    <div class="info">Genuary Day 1: One Color, One Shape | Click to regenerate</div>
    
    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        
        // Set canvas size
        const size = Math.min(window.innerWidth, window.innerHeight) * 0.85;
        canvas.width = size;
        canvas.height = size;
        
        // One color - warm coral/salmon
        const HUE = 0;  // Red hue
        const SAT = 75;
        const BASE_LIGHT = 65;
        
        function getColor(alpha = 1, lightOffset = 0) {
            return `hsla(${HUE}, ${SAT}%, ${BASE_LIGHT + lightOffset}%, ${alpha})`;
        }
        
        // One shape - circles
        function drawCircle(x, y, radius, alpha = 1, lightOffset = 0) {
            ctx.beginPath();
            ctx.arc(x, y, radius, 0, Math.PI * 2);
            ctx.fillStyle = getColor(alpha, lightOffset);
            ctx.fill();
        }
        
        function drawCircleOutline(x, y, radius, lineWidth = 1, alpha = 1, lightOffset = 0) {
            ctx.beginPath();
            ctx.arc(x, y, radius, 0, Math.PI * 2);
            ctx.strokeStyle = getColor(alpha, lightOffset);
            ctx.lineWidth = lineWidth;
            ctx.stroke();
        }
        
        // Easing function
        function easeOutQuart(t) {
            return 1 - Math.pow(1 - t, 4);
        }
        
        function generate() {
            // Clear canvas
            ctx.fillStyle = '#0a0a0a';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            const centerX = canvas.width / 2;
            const centerY = canvas.height / 2;
            const maxRadius = Math.min(centerX, centerY) * 0.9;
            
            // Pattern selection
            const pattern = Math.floor(Math.random() * 4);
            
            if (pattern === 0) {
                // Concentric circles with varying opacity
                const numRings = 15 + Math.floor(Math.random() * 20);
                for (let i = numRings; i >= 0; i--) {
                    const t = i / numRings;
                    const radius = maxRadius * easeOutQuart(t);
                    const alpha = 0.1 + (1 - t) * 0.6;
                    const lightOffset = (1 - t) * 15 - 10;
                    
                    if (Math.random() > 0.3) {
                        drawCircle(centerX, centerY, radius, alpha, lightOffset);
                    } else {
                        drawCircleOutline(centerX, centerY, radius, 2 + Math.random() * 3, alpha, lightOffset);
                    }
                }
                
                // Add scattered small circles
                for (let i = 0; i < 100; i++) {
                    const angle = Math.random() * Math.PI * 2;
                    const dist = Math.random() * maxRadius * 0.95;
                    const x = centerX + Math.cos(angle) * dist;
                    const y = centerY + Math.sin(angle) * dist;
                    const r = 2 + Math.random() * 8;
                    const alpha = 0.2 + Math.random() * 0.5;
                    drawCircle(x, y, r, alpha, Math.random() * 20 - 10);
                }
                
            } else if (pattern === 1) {
                // Spiral of circles
                const numCircles = 200 + Math.floor(Math.random() * 150);
                const spiralTightness = 0.15 + Math.random() * 0.1;
                const goldenAngle = Math.PI * (3 - Math.sqrt(5));
                
                for (let i = 0; i < numCircles; i++) {
                    const t = i / numCircles;
                    const angle = i * goldenAngle;
                    const dist = maxRadius * Math.sqrt(t) * 0.95;
                    
                    const x = centerX + Math.cos(angle) * dist;
                    const y = centerY + Math.sin(angle) * dist;
                    
                    const baseRadius = 3 + (1 - t) * 15;
                    const radius = baseRadius * (0.5 + Math.random() * 0.5);
                    const alpha = 0.3 + t * 0.5;
                    const lightOffset = t * 20 - 5;
                    
                    if (Math.random() > 0.2) {
                        drawCircle(x, y, radius, alpha, lightOffset);
                    } else {
                        drawCircleOutline(x, y, radius * 1.5, 1.5, alpha, lightOffset);
                    }
                }
                
            } else if (pattern === 2) {
                // Grid of circles with wave distortion
                const gridSize = 12 + Math.floor(Math.random() * 8);
                const cellSize = (maxRadius * 2) / gridSize;
                const waveFreq = 0.1 + Math.random() * 0.15;
                const waveAmp = cellSize * (0.3 + Math.random() * 0.4);
                const phase = Math.random() * Math.PI * 2;
                
                for (let row = 0; row < gridSize; row++) {
                    for (let col = 0; col < gridSize; col++) {
                        const baseX = centerX - maxRadius + cellSize * (col + 0.5);
                        const baseY = centerY - maxRadius + cellSize * (row + 0.5);
                        
                        // Check if within main circle
                        const dx = baseX - centerX;
                        const dy = baseY - centerY;
                        if (Math.sqrt(dx * dx + dy * dy) > maxRadius * 0.95) continue;
                        
                        // Wave distortion
                        const offsetX = Math.sin(row * waveFreq * 2 + phase) * waveAmp;
                        const offsetY = Math.cos(col * waveFreq * 2 + phase) * waveAmp;
                        
                        const x = baseX + offsetX;
                        const y = baseY + offsetY;
                        
                        const distFromCenter = Math.sqrt((x - centerX) ** 2 + (y - centerY) ** 2) / maxRadius;
                        const radius = cellSize * 0.35 * (1 - distFromCenter * 0.5);
                        const alpha = 0.4 + (1 - distFromCenter) * 0.5;
                        const lightOffset = (1 - distFromCenter) * 15;
                        
                        drawCircle(x, y, radius, alpha, lightOffset);
                    }
                }
                
                // Outer ring
                drawCircleOutline(centerX, centerY, maxRadius, 3, 0.6, 10);
                
            } else {
                // Packed circles (simple version)
                const circles = [];
                const attempts = 2000;
                const minRadius = 4;
                const maxCircleRadius = 50;
                
                for (let i = 0; i < attempts; i++) {
                    const angle = Math.random() * Math.PI * 2;
                    const dist = Math.random() * maxRadius * 0.9;
                    const x = centerX + Math.cos(angle) * dist;
                    const y = centerY + Math.sin(angle) * dist;
                    
                    // Find max radius that doesn't overlap
                    let radius = maxCircleRadius;
                    
                    // Check distance to edge
                    const edgeDist = maxRadius - Math.sqrt((x - centerX) ** 2 + (y - centerY) ** 2);
                    radius = Math.min(radius, edgeDist);
                    
                    // Check distance to other circles
                    for (const c of circles) {
                        const d = Math.sqrt((x - c.x) ** 2 + (y - c.y) ** 2);
                        radius = Math.min(radius, d - c.r - 2);
                    }
                    
                    if (radius >= minRadius) {
                        circles.push({ x, y, r: radius });
                    }
                }
                
                // Sort by size for nice layering
                circles.sort((a, b) => b.r - a.r);
                
                // Draw circles
                for (const c of circles) {
                    const distFromCenter = Math.sqrt((c.x - centerX) ** 2 + (c.y - centerY) ** 2) / maxRadius;
                    const alpha = 0.3 + (1 - distFromCenter) * 0.5;
                    const lightOffset = (c.r / maxCircleRadius) * 20 - 5;
                    
                    if (Math.random() > 0.15) {
                        drawCircle(c.x, c.y, c.r, alpha, lightOffset);
                    } else {
                        drawCircleOutline(c.x, c.y, c.r, 2, alpha * 1.2, lightOffset + 5);
                    }
                }
            }
            
            // Add subtle center glow
            const gradient = ctx.createRadialGradient(centerX, centerY, 0, centerX, centerY, maxRadius * 0.5);
            gradient.addColorStop(0, getColor(0.15, 20));
            gradient.addColorStop(1, 'transparent');
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, canvas.width, canvas.height);
        }
        
        // Initial generation
        generate();
        
        // Regenerate on click
        canvas.addEventListener('click', generate);
        
        // Handle resize
        window.addEventListener('resize', () => {
            const size = Math.min(window.innerWidth, window.innerHeight) * 0.85;
            canvas.width = size;
            canvas.height = size;
            generate();
        });
    </script>
</body>
</html>
