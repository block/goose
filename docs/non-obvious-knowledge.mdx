---
title: Non-Obvious Knowledge — Goose4
updated: 2026-02-18
session: "feature/cli-via-goosed"
commits: "665fd046..fb47a58a"
---

# Non-Obvious Knowledge

Hard-won insights from building Goose that aren't documented elsewhere. Each entry was discovered through debugging or design iteration — not from reading docs.

---

## Architecture

### OpenAPI Generation Pipeline

The OpenAPI spec generation has a **3-step pipeline** that's easy to break:

1. `cargo run -p goose-server --bin generate_schema` → writes `ui/desktop/openapi.json`
2. `npx @hey-api/openapi-ts` → reads `openapi.json`, generates `sdk.gen.ts`, `types.gen.ts`, `index.ts`
3. **DANGER:** Step 2 **deletes** `src/api/instances.ts` — this is a hand-written file that must be restored via `git checkout HEAD -- ui/desktop/src/api/instances.ts` after every `just generate-openapi`

To register new routes in the OpenAPI spec, you must edit **3 files**:
- `crates/goose-server/src/routes/mod.rs` — `pub mod <module>;` + `.merge(<module>::routes(state.clone()))`
- `crates/goose-server/src/openapi.rs` — add path handlers to `paths()` + types to `schemas()`
- `crates/goose-server/src/main.rs` — `mod <module>;` (for the binary target)

All three must be consistent or the types won't appear in the frontend SDK.

### Binary vs Library Crate Split in goose-server

`goose-server` has both a library (`lib.rs`) and a binary (`main.rs`). The binary re-declares `mod routes;`, `mod auth;`, etc. This means:

- **`crate::auth` resolves differently** depending on which target is compiling
- When adding new modules, you MUST add `mod <name>;` to BOTH `lib.rs` AND `main.rs`
- The `check_token` function has `#[allow(dead_code)]` because it's used via the lib (`goose_server::auth::check_token` in `commands/agent.rs`) but not directly in the binary

### Dual Axum Versions (0.7 + 0.8)

The `a2a` crate pulls in `tonic` which depends on axum 0.7. The goose-server uses axum 0.8 directly. This causes:

- **Cannot use `FromRequestParts` extractor pattern** — the trait exists in both versions and the compiler gets confused
- **Solution:** Use `from_headers(&HeaderMap)` manual extraction instead of Axum's extractor pattern
- The `RequestIdentity::from_headers_validated()` takes `&HeaderMap` directly for this reason

### Pipeline Module Repeatedly Breaks Builds

`crates/goose-server/src/routes/pipeline.rs` and `crates/goose/src/pipeline.rs` (frontend agent work) repeatedly cause build failures when module declarations in `lib.rs`, `routes/mod.rs`, and `openapi.rs` get out of sync. Pipeline handlers lack utoipa annotations, causing OpenAPI schema generation to fail.

---

## Auth & Identity

### Auth Priority Chain (6 levels)

`from_headers_validated()` resolves identity through a strict priority chain:

```
1. Session JWT (our tokens from /auth/login) → SessionTokenStore validates
2. OIDC JWT (signature validated against JWKS) → OidcValidator validates
3. Lightweight JWT decode (base64 payload, no sig check) → unvalidated fallback
4. X-Goose-Api-Key header → ApiKey identity (X-Api-Key legacy fallback)
5. X-Goose-User-Id header → stable guest (deterministic UUID from value)
6. (nothing) → anonymous guest (random UUID per request)
```

Steps 1-3 all parse the `Authorization: Bearer <token>` header. The system tries each in order — if session JWT validation fails, it tries OIDC, then lightweight decode.

### `Provider::complete()` vs `Agent::reply()` — Different Types

`Provider::complete()` takes `conversation::message::Message` (the goose message type). A2A uses `a2a::types::Message`. These are **completely different types** — you cannot pass one where the other is expected.

The `InProcessDispatcher` uses `Provider::complete()` (single-turn, no tools). The `AgentReplyDispatcher` uses `Agent::reply()` (multi-turn, full tool use). The inline compound execution code in reply.rs was replaced with `dispatch_compound_sequential` which uses `AgentReplyDispatcher`.

### ProtoJSON is Normative, Not JSON Schema

The A2A spec uses **ProtoJSON** format (from protobuf):
- Enums: `"TASK_STATE_WORKING"` (SCREAMING_SNAKE_CASE), NOT `"working"` (lowercase)
- JSON-RPC methods: `"SendMessage"` (PascalCase), NOT `"message/send"` (slash-style)

The JavaScript SDK (a2a-js v0.3.10) is **non-compliant** — it uses lowercase enums. Our `Deserialize` impls accept BOTH formats (lenient deserialization) for interop, but `Serialize` always produces ProtoJSON.

### `OidcProviderConfig.audience` is `String`, Not `Option<String>`

When looking up audience for auth URL generation, use `.map(|p| p.audience.clone())`, NOT `.and_then(|p| p.audience.clone())`. The field is non-optional.

### GitHub Doesn't Support Standard OIDC Code Flow

GitHub uses OAuth2 (not full OIDC) for user authentication. `github.com` doesn't have a `/.well-known/openid-configuration` endpoint. The `OidcProviderPreset::GitHub` variant has `supports_oidc_code_flow() == false` and provides separate `oauth2_authorize_url()` / `oauth2_token_url()` methods.

GitHub Actions tokens DO support OIDC (via `token.actions.githubusercontent.com`), but that's for CI, not user login.

### Session Token vs OIDC Token — Different Stores

- **Session tokens** (from `/auth/login`): Stored in `SessionTokenStore` (SQLite), validated by checking signature + JTI revocation list
- **OIDC tokens** (from provider): Validated by `OidcValidator` against provider's JWKS, not stored server-side
- **Refresh tokens**: Stored in `SessionTokenStore` SQLite keyed by (issuer, subject)

### JWKS Key Rotation — Retry on KeyNotFound

When an OIDC provider rotates signing keys, existing cached JWKS won't contain the new `kid`. The validator handles this:
1. Look up key by `kid` in cached JWKS
2. If `KeyNotFound` → invalidate JWKS cache for that issuer
3. Refetch JWKS from provider
4. Retry key lookup once
5. If still not found → real error

This is critical for production — without it, key rotation causes auth failures until cache TTL expires.

### `OidcTokenSet.id_token` is `Option<String>`

In the initial code exchange, `id_token` is always present. But in refresh token responses, providers may NOT return a new `id_token`. That's why the field is `Option<String>` — the code exchange handler unwraps it with a 502 error if missing.

### Rate Limiter Uses IP Extraction Priority

```
1. X-Forwarded-For header (first IP in comma-separated list) — for reverse proxies
2. X-Real-IP header — for nginx
3. "127.0.0.1" fallback — for direct connections
```

The rate limiter is applied ONLY to `/auth/*` routes via a nested Axum router, not to all routes.

---

## Frontend

### React Flow v12 Type Compatibility

`@xyflow/react` v12 requires node data types to satisfy `Record<string, unknown>`. Custom interfaces like `DagNodeData` need an **index signature**:

```typescript
export interface DagNodeData {
  kind: NodeKind;
  label: string;
  [key: string]: unknown;  // REQUIRED for React Flow v12 compat
}
```

### Lucide Icons Don't Accept `style` Prop

Lucide React icons (v0.400+) don't accept a `style` prop. To apply inline colors, wrap in a `<span>`:

```tsx
// ❌ Won't compile
<Icon size={16} style={{ color }} />

// ✅ Works
<span style={{ color }}><Icon size={16} /></span>
```

### `authInterceptor.ts` is NOT Auto-Generated

`ui/desktop/src/api/authInterceptor.ts` is a **hand-written** file that survives `just generate-openapi` (unlike `sdk.gen.ts` and `types.gen.ts`). It attaches `Authorization: Bearer` and `X-Secret-Key` headers to every API call.

If the generated client changes its interceptor API (e.g., `@hey-api/openapi-ts` major version bump), this file needs manual updating.

### localStorage Keys for Auth

```
goose_auth_token     — session JWT (from /auth/login)
goose_auth_user      — serialized user object
goose_auth_token_expiry — ISO timestamp of token expiration
secretKey            — server secret key (for X-Secret-Key header)
```

The `useAuth` hook manages these. The `authInterceptor` reads them. Both must stay in sync on the key names.

### OIDC Login Uses Custom Protocol Handler

The desktop app registers `goose://auth/callback` as a deep link handler. OIDC login flow:
1. `useAuth.loginWithOidc(issuer)` requests auth URL from server
2. Opens system browser to provider login page with `redirect_uri=goose://auth/callback`
3. After auth, browser redirects to `goose://auth/callback?code=XXX&state=YYY`
4. Electron intercepts the deep link, extracts code+state
5. Exchanges code for session token via server

---

## Agent & Dispatch

### `SlotDelegation` Methods are `#[allow(dead_code)]`

`register_a2a_agent`, `register_acp_agent`, `unregister_agent` in `agent_slot_registry.rs` are tested but not all called from production code yet. They're kept with `#[allow(dead_code)]` for forward compatibility.

### `for_sub_agent()` Creates Child Identity Chain

When compound execution dispatches to sub-agents, `ExecutionIdentity::for_sub_agent(kind, persona)` creates a new `AgentIdentity` with:
- New UUID
- `parent_id` pointing to the parent agent
- `spawned_by` recording the parent agent's display name
- Same `UserIdentity` (the human user stays the same)

This chain is preserved in A2A metadata via `to_a2a_metadata()`.

### `dispatch_compound_sequential` Replaced 155 Lines

The inline compound execution code in `reply.rs` was extracted into `dispatch_compound_sequential` in `dispatch.rs`. The replacement:
- Uses `AgentReplyDispatcher` for in-process (full `agent.reply()` with tools)
- Uses `A2ADispatcher` for remote A2A
- Routes based on `SlotDelegation` lookup per sub-task agent name
- Sequential execution (not parallel) — same as the original inline code

### `OrchestratorAgent::new()` Takes `Arc<Mutex<Option<Provider>>>`

Not a direct provider — it's wrapped in `Arc<Mutex<Option<...>>>`. Easy to get wrong when constructing.

---

## Data & Persistence

### SQLite Token Store Schema

```sql
-- data_dir/auth/tokens.db
CREATE TABLE schema_version (version INTEGER NOT NULL);
CREATE TABLE revoked_tokens (
    jti TEXT PRIMARY KEY,
    revoked_at TEXT NOT NULL,
    expires_at TEXT NOT NULL  -- for cleanup of old revocations
);
CREATE TABLE refresh_tokens (
    issuer TEXT NOT NULL,
    subject TEXT NOT NULL,
    refresh_token TEXT NOT NULL,
    stored_at TEXT NOT NULL,
    PRIMARY KEY (issuer, subject)
);
```

### Session Schema Version 9

The session storage is at schema version 9 with `tenant_id TEXT` and `user_id TEXT` columns. Migrations run automatically on startup. The `set_session_identity` method uses a raw SQL UPDATE to tag sessions.

### `list_sessions_for_tenant` Uses Dynamic SQL

The method builds a WHERE clause dynamically based on which filters are provided:
- Both tenant and user → `WHERE tenant_id = ? AND user_id = ?`
- Only tenant → `WHERE tenant_id = ?`
- Only user → `WHERE user_id = ?`
- Neither → `WHERE session_type IN ('user', 'scheduled')` (no tenant filtering)

---

## Testing

### Flaky Test: `prepare_tools_returns_sorted_tools_including_frontend`

This test in `agents::reply_parts` is intermittently flaky — fails in batch runs but passes individually. Root cause unknown. Not related to any recent changes.

### `jsonwebtoken` Default Leeway is 60 Seconds

When testing expired tokens, don't create a token with `exp = now` and expect immediate failure — `jsonwebtoken::Validation` has a 60-second default leeway. Either:
- Set `validation.leeway = 0` explicitly
- Create tokens with `exp` far in the past (e.g., year 1970)

### `just generate-openapi` Deletes `instances.ts`

Every time you run `just generate-openapi`, it deletes `ui/desktop/src/api/instances.ts` (a hand-written wrapper). The `just` recipe automatically restores it via `git checkout`, but if you're running the steps manually, you'll lose the file.
