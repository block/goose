---
title: "Non-Obvious Knowledge: Goose Multi-Agent Architecture"
type: knowledge
date: 2026-02-17
updated: 2026-02-17T21:54:00Z
confidence: 0.95
tags: [a2a, architecture, gotchas, non-obvious]
---

# Non-Obvious Knowledge: Goose Multi-Agent Architecture

## A2A Spec Compliance

### 1. ProtoJSON is Normative, JSON Schema is NOT
- The `a2a.proto` file is the **single source of truth** (spec §1.4)
- The JSON Schema artifact (`a2a.json`) is a **non-normative build artifact**
- The official JS SDK (`a2a-js v0.3.10`) generates types from the JSON Schema and is **non-compliant** with ADR-001
- Our Rust implementation is **more spec-compliant** than the official JS SDK
- **Evidence**: `a2a-js/package.json` has `generate` script that curls `a2a.json` from GitHub

### 2. Enum Serialization: SCREAMING_SNAKE_CASE Required
- Per ADR-001 and spec §5.5: enums MUST serialize as `TASK_STATE_WORKING`, `ROLE_USER`
- The JS SDK uses `"working"`, `"user"` — this is **spec-non-compliant**
- We implement **lenient deserialization**: accept both formats, always serialize to spec format
- **Migration timeline** (spec Appendix A): 0.3.x new names alongside legacy, 0.4.x deprecated, ≥0.5.0 removed

### 3. JSON-RPC Method Names: PascalCase Required
- Spec §9.4 mandates: `SendMessage`, `GetTask`, `CancelTask` (PascalCase)
- JS SDK uses: `"message/send"`, `"tasks/get"` (slash-style) — also **non-compliant**
- We accept both PascalCase and legacy slash-style in our handler

### 4. A2A Error Codes Range: -32001 to -32009
- Spec defines 9 A2A-specific error codes (separate from standard JSON-RPC -327xx codes)
- Our implementation has all 9; the JS SDK only has 7 (missing -32008 and -32009)

## Architecture Gotchas

### 5. AgentPool Uses session_id as instance_id
- `AgentPool::spawn()` creates a session and uses the session ID as the pool instance ID
- This means agent "instances" are really sessions — there's no persistent agent identity
- Relevant for the dual identity proposal: agent IDs need a separate lifecycle from sessions

### 6. OrchestratorAgent Needs a Provider But Often Doesn't Use It
- `OrchestratorAgent::new(provider)` takes `Arc<Mutex<Option<Provider>>>`
- For slot enumeration and routing, the provider is never called
- In observatory.rs, we pass `Arc::new(Mutex::new(None))` as a dummy provider
- Consider splitting OrchestratorAgent into RoutingCatalog (no provider) + PlanExecutor (needs provider)

### 7. Per-Agent Extension Scoping is Already Fully Wired
- The chain: `AgentSlotRegistry.bind_extension()` → `reply.rs` syncs to OrchestratorAgent slots → `apply_routing()` reads `slot.bound_extensions` → `agent.set_allowed_extensions()` → `prepare_tools_and_prompt()` filters tools (reply_parts.rs:204-213)
- **No additional code needed** — just use `bind_extension`/`unbind_extension` endpoints
- The reply.rs sync loop was hardcoded to `["Goose Agent", "Developer Agent"]` — now uses dynamic `all_agent_names()`

### 8. Pipeline Module is Frontend Agent WIP — DO NOT Enable
- `crates/goose-server/src/routes/pipeline.rs` and `crates/goose/src/pipeline.rs` are untracked
- They reference `goose::pipeline` which doesn't exist in `lib.rs` yet
- The module declarations and OpenAPI refs in `mod.rs` and `openapi.rs` are **commented out**
- The frontend agent keeps re-enabling them — this breaks the build
- **Fix**: The frontend agent needs to add `pub mod pipeline;` to `goose/src/lib.rs` AND add utoipa annotations to pipeline route handlers before uncommenting

### 9. Provider::complete() Signature is Not What You Expect
- `provider.complete(session_id, system, messages, tools)` takes `Option<&str>` for session_id
- The `Message` type is `crate::conversation::message::Message`, NOT `a2a::types::core::Message`
- The `Tool` type is `mcp_core::tool::Tool` from the MCP protocol
- When building a Dispatcher, you must convert between A2A Messages and conversation Messages

### 10. The generate_schema Binary Must Be Rebuilt After openapi.rs Changes
- `just generate-openapi` runs `cargo run -p goose-server --bin generate_schema`
- If you only edit `openapi.rs` without rebuilding, the binary uses the **old** compiled schema
- Always do `cargo build -p goose-server` first, THEN `just generate-openapi`
- The TypeScript types won't appear in `types.gen.ts` until both steps complete

### 11. AgentSlotRegistry vs IntentRouter Slot Binding
- `AgentSlotRegistry` (server-side, in `goose-server`) stores enabled/disabled + bound extensions + delegation strategy
- `IntentRouter` (core, in `goose`) has its own `AgentSlot` with `bound_extensions`
- These are **separate data stores** — `reply.rs` syncs from registry → router on each request
- Changes to the registry don't take effect until the next reply request syncs them

### 12. Compound Execution is Sequential, Not Parallel
- When `OrchestratorPlan.is_compound == true` with multiple tasks, they execute **sequentially** in `reply.rs`
- Each sub-task gets its own `apply_routing()` call, creating a separate agent config
- Results are aggregated via `aggregate_results()` into a single response
- **Phase 2 TODO**: Wire `CompositeDispatcher` for parallel AgentPool-based fan-out

### 13. SlotDelegation Enum is Allow(dead_code) — By Design
- `SlotDelegation::RemoteA2A { url }` and `ExternalAcp` are defined but not yet wired into production dispatch
- The `#[allow(dead_code)]` annotations are intentional — the types are tested and ready
- The compound execution in reply.rs currently only does InProcess dispatch
- Wiring A2A dispatch requires creating `A2AClient` from the slot's URL and using `A2ADispatcher`

## A2A Spec Reference Quick-Hits

### 14. REST Binding Exists But We Only Implement JSON-RPC
- Spec §11 defines a full HTTP+JSON/REST binding: `POST /message:send`, `GET /tasks/{id}`
- We only implement the JSON-RPC binding (§9)
- The REST binding uses RFC 9457 Problem Details for errors, SSE for streaming
- **Low priority**: JSON-RPC is sufficient for all current use cases

### 15. A2A Spec Migration Timeline (Appendix A)
- **0.3.x**: New names introduced alongside legacy names (WE ARE HERE)
- **0.4.x**: Legacy names deprecated
- **≥0.5.0**: Legacy names eligible for removal
- Our lenient deserialization handles both — safe through 0.5.x
