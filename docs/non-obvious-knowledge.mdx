---
title: Non-Obvious Knowledge — Goose4
updated: 2026-02-19
session: "feature/cli-via-goosed"
commits: "665fd046..d373412f"
---

# Non-Obvious Knowledge

Hard-won insights from building Goose that aren't documented elsewhere. Each entry was discovered through debugging or design iteration — not from reading docs.

---

## Architecture

### OpenAPI Generation Pipeline

The OpenAPI spec generation has a **3-step pipeline** that's easy to break:

1. `cargo run -p goose-server --bin generate_schema` → writes `ui/desktop/openapi.json`
2. `npx @hey-api/openapi-ts` → reads `openapi.json`, generates `sdk.gen.ts`, `types.gen.ts`, `index.ts`
3. **DANGER:** Step 2 **deletes** `src/api/instances.ts` — this is a hand-written file that must be restored via `git checkout HEAD -- ui/desktop/src/api/instances.ts` after every `just generate-openapi`

To register new routes in the OpenAPI spec, you must edit **3 files**:
- `crates/goose-server/src/routes/mod.rs` — `pub mod <module>;` + `.merge(<module>::routes(state.clone()))`
- `crates/goose-server/src/openapi.rs` — add path handlers to `paths()` + types to `schemas()`
- `crates/goose-server/src/main.rs` — `mod <module>;` (for the binary target)

All three must be consistent or the types won't appear in the frontend SDK.

### Binary vs Library Crate Split in goose-server

`goose-server` has both a library (`lib.rs`) and a binary (`main.rs`). The binary re-declares `mod routes;`, `mod auth;`, etc. This means:

- **`crate::auth` resolves differently** depending on which target is compiling
- When adding new modules, you MUST add `mod <name>;` to BOTH `lib.rs` AND `main.rs`
- The `check_token` function has `#[allow(dead_code)]` because it's used via the lib (`goose_server::auth::check_token` in `commands/agent.rs`) but not directly in the binary

### Dual Axum Versions (0.7 + 0.8)

The `a2a` crate pulls in `tonic` which depends on axum 0.7. The goose-server uses axum 0.8 directly. This causes:

- **Cannot use `FromRequestParts` extractor pattern** — the trait exists in both versions and the compiler gets confused
- **Solution:** Use `from_headers(&HeaderMap)` manual extraction instead of Axum's extractor pattern
- The `RequestIdentity::from_headers_validated()` takes `&HeaderMap` directly for this reason
- **`authorize_middleware` uses `Extension<Arc<T>>` not `State<Arc<T>>`** — for the same reason. `from_fn_with_state` doesn't work when the router has already been typed with a different state type (`String` for `check_token`). Extensions bypass the state system entirely.

### Pipeline Module Repeatedly Breaks Builds

`crates/goose-server/src/routes/pipeline.rs` and `crates/goose/src/pipeline.rs` (frontend agent work) repeatedly cause build failures when module declarations in `lib.rs`, `routes/mod.rs`, and `openapi.rs` get out of sync. Pipeline handlers lack utoipa annotations, causing OpenAPI schema generation to fail.

### `#[allow(dead_code)]` Required for Route-Handler-Only Functions

Functions in the `goose-server` lib that are only used by route handlers appear as dead code to clippy. This is because clippy analyses the lib and bin targets separately — route handlers are registered dynamically through the axum Router, so clippy can't see the call chain. Affected:
- `authorize_middleware`, `route_to_policy` in `auth.rs`
- `AgentSlotRegistry` methods (`set_delegation`, `register_a2a_agent`, `all_agents`, etc.)
- Solution: `#[allow(dead_code)]` on the impl block or individual methods

---

## Authentication & Authorization

### Auth Header Priority Chain (6 levels)

The `RequestIdentity` extractor in `auth.rs` resolves identity via this priority chain:

```
1. Session JWT (our /auth/login tokens) → SessionTokenStore validates
2. OIDC JWT (with registered providers) → OidcValidator validates (JWKS)
3. Lightweight JWT decode (no signature check) → fallback for unknown issuers
4. X-Api-Key header → from_api_key() with prefixed ID
5. X-Goose-User-Id header → stable guest (deterministic ID)
6. (nothing) → anonymous guest (random UUID per request)
```

`X-Api-Key` is the **industry standard** header — a previous rename to `X-Goose-Api-Key` was reverted because the Anthropic collision concern was theoretical (different HTTP connections to different hosts).

### Middleware Execution Order

The middleware chain in `commands/agent.rs` uses axum layers (applied in reverse order):

```
Request → CORS → check_token (X-Secret-Key) → Extension layers → authorize_middleware → Route Handler
```

- `check_token`: Validates the server's shared secret (machine-to-machine auth)
- `authorize_middleware`: Evaluates PolicyStore + QuotaManager, emits AuditEvent
- Extension layers inject `Arc<PolicyStore>`, `Arc<AuditLogger>`, `Arc<QuotaManager>` into request extensions
- Extensions must be layered ABOVE (after in code) `authorize_middleware` so they're available when it runs

### OIDC Provider Quirks

- **GitHub doesn't support standard OIDC code flow** — it needs a separate OAuth2 handler
- **GitLab + AWS Cognito** have non-standard issuer URL formats that need special handling in `issuer_to_provider()`
- **JWT leeway defaults to 60 seconds** — `jsonwebtoken::Validation` has this built-in. Test expired tokens with `exp` far in the past (e.g., year 1970), not with `exp = now`

### CLI Session Tokens Now in System Keyring

As of commit `97fa1e4a`, CLI session tokens are stored in the system keyring via `Config::global().set_secret("goose_session_token", &stored)` instead of plaintext `~/.config/goose/session_token.json`. Auto-migration: `migrate_legacy_token()` reads the old JSON file, stores in keyring, deletes the file. Fallback to `secrets.yaml` if keyring is unavailable.

### Policy Engine Evaluation Semantics

- **First-match wins**: Rules sorted by priority (lower number = higher priority)
- **Abstain**: If no rule matches, returns `Abstain` — the middleware treats this as "allow" (permissive default)
- **RBAC check**: If a rule has `required_roles`, user must have **at least one** matching role (OR logic, not AND)
- **Wildcard matching**: `execute:*` matches `execute:reply`, `execute:tool`. `*` alone matches everything
- **Tenant scoping**: Rules can be tenant-specific. `PolicyStore::engine_for(tenant)` merges global + tenant rules
- **Default rules**: `deny-guest-management` (guests can't `manage:*`), `allow-execute` (all can `execute:*`), `allow-read` (all can `read:*`)

### Quota Hierarchical Scope Matching

`QuotaScope` has hierarchical matching where broader scopes apply to narrower ones:
- `Global` limit applies to ALL scopes (Tenant, User, TenantUser)
- `Tenant("acme")` limit applies to `TenantUser { tenant: "acme", user: _ }`
- Usage is tracked per **exact scope** — a Global limit checks usage recorded at the Global scope, not summed across tenants

This means: if you set a Global limit of 100 executions/hour, each tenant independently counts toward that 100 at their own scope level. A global limit doesn't aggregate across tenants.

---

## Desktop / Frontend

### localStorage Keys for Auth

The desktop app stores auth state in localStorage with these keys:
```
goose_auth_token     — session JWT (from /auth/login)
goose_auth_user      — serialized user object
goose_auth_token_expiry — ISO timestamp of token expiration
secretKey            — server secret key (for X-Secret-Key header)
```

The `useAuth` hook manages these. The `authInterceptor` reads them. Both must stay in sync on the key names.

### OIDC Login Uses Custom Protocol Handler

The desktop app registers `goose://auth/callback` as a deep link handler. OIDC login flow:
1. `useAuth.loginWithOidc(issuer)` requests auth URL from server
2. Opens system browser to provider login page with `redirect_uri=goose://auth/callback`
3. After auth, browser redirects to `goose://auth/callback?code=XXX&state=YYY`
4. Electron intercepts the deep link, extracts code+state
5. Exchanges code for session token via server

---

## Agent & Dispatch

### `SlotDelegation` Methods are `#[allow(dead_code)]`

`register_a2a_agent`, `register_acp_agent`, `unregister_agent` in `agent_slot_registry.rs` are tested but not all called from production code yet. They're kept with `#[allow(dead_code)]` for forward compatibility. The entire `impl AgentSlotRegistry` block has `#[allow(dead_code)]` since many persistence methods (e.g., `with_persistence`, `init`, `run_migrations`, `load_from_db`) are only called internally.

### `for_sub_agent()` Creates Child Identity Chain

When compound execution dispatches to sub-agents, `ExecutionIdentity::for_sub_agent(kind, persona)` creates a new `AgentIdentity` with:
- New UUID
- `parent_id` pointing to the parent agent
- `spawned_by` recording the parent agent's display name
- Same `UserIdentity` (the human user stays the same)

This chain is preserved in A2A metadata via `to_a2a_metadata()`.

### `dispatch_compound_sequential` Replaced 155 Lines

The inline compound execution code in `reply.rs` was extracted into `dispatch_compound_sequential` in `dispatch.rs`. The replacement:
- Uses `AgentReplyDispatcher` for in-process (full `agent.reply()` with tools)
- Uses `A2ADispatcher` for remote A2A
- Routes based on `SlotDelegation` lookup per sub-task agent name
- Sequential execution (not parallel) — same as the original inline code

### `OrchestratorAgent::new()` Takes `Arc<Mutex<Option<Provider>>>`

Not a direct provider — it's wrapped in `Arc<Mutex<Option<...>>>`. Easy to get wrong when constructing.

---

## Data & Persistence

### SQLite Token Store Schema

```sql
-- data_dir/auth/tokens.db
CREATE TABLE schema_version (version INTEGER NOT NULL);
CREATE TABLE revoked_tokens (
    jti TEXT PRIMARY KEY,
    revoked_at TEXT NOT NULL,
    expires_at TEXT NOT NULL  -- for cleanup of old revocations
);
CREATE TABLE refresh_tokens (
    issuer TEXT NOT NULL,
    subject TEXT NOT NULL,
    refresh_token TEXT NOT NULL,
    stored_at TEXT NOT NULL,
    PRIMARY KEY (issuer, subject)
);
```

### AgentSlotRegistry SQLite Schema

```sql
-- data_dir/agents/registry.db
CREATE TABLE schema_version (version INTEGER NOT NULL);
CREATE TABLE agents (
    name TEXT PRIMARY KEY,
    enabled INTEGER NOT NULL DEFAULT 1,
    delegation_type TEXT NOT NULL DEFAULT 'in_process',
    delegation_url TEXT
);
CREATE TABLE agent_extensions (
    agent_name TEXT NOT NULL,
    extension_name TEXT NOT NULL,
    PRIMARY KEY (agent_name, extension_name),
    FOREIGN KEY (agent_name) REFERENCES agents(name) ON DELETE CASCADE
);
```

Lazy pool initialization following the `SessionTokenStore` pattern. Falls back to in-memory when no `data_dir` is provided (tests).

### Session Schema Version 9

The session storage is at schema version 9 with `tenant_id TEXT` and `user_id TEXT` columns. Migrations run automatically on startup. The `set_session_identity` method uses a raw SQL UPDATE to tag sessions.

### `list_sessions_for_tenant` Uses Dynamic SQL

The method builds a WHERE clause dynamically based on which filters are provided:
- Both tenant and user → `WHERE tenant_id = ? AND user_id = ?`
- Only tenant → `WHERE tenant_id = ?`
- Only user → `WHERE user_id = ?`
- Neither → `WHERE session_type IN ('user', 'scheduled')` (no tenant filtering)

---

## Control Plane (Enterprise ACP)

### Control Plane API Design

The `/control-plane/v1/*` endpoints are designed for external enterprise control planes (Azure AI Controls, GitHub Enterprise, AWS):

| Endpoint | Method | Purpose |
|---|---|---|
| `/control-plane/v1/info` | GET | System capabilities, version, features |
| `/control-plane/v1/policies` | GET/POST | List/create policy rules |
| `/control-plane/v1/policies/:id` | DELETE | Remove a policy rule |
| `/control-plane/v1/quotas` | GET/POST | List/create quota limits |
| `/control-plane/v1/quotas/check` | POST | Check if a scope is within limits |
| `/control-plane/v1/audit` | GET | Recent audit events |
| `/control-plane/v1/agents` | GET/POST | List/register agents |
| `/control-plane/v1/agents/:name` | DELETE | Unregister an agent |

### PolicyStore + QuotaManager + AuditLogger in AppState

All three are `Arc`-wrapped in `AppState` and injected into the middleware via `Extension` layers:

```rust
// In commands/agent.rs
.layer(Extension(app_state.quota_manager.clone()))
.layer(Extension(app_state.audit_logger.clone()))
.layer(Extension(app_state.policy_store.clone()))
.layer(middleware::from_fn(authorize_middleware))
```

The order matters: Extension layers must be ABOVE `from_fn(authorize_middleware)` so extensions are in the request when the middleware runs (axum processes layers bottom-up for requests).

### `route_to_policy` Action Mapping

Maps HTTP method + path to policy action/resource pairs:
- `POST /reply` → `execute:reply`
- `GET /sessions` → `session:list`
- `POST /sessions/*/reply` → `execute:reply`
- `GET /agents/*` → `read:agents`
- `POST /control-plane/v1/policies` → `manage:policies`
- `DELETE /agents/*` → `manage:agents`
- Default: `{method}:{first_path_segment}`

---

## Testing

### Flaky Test: `prepare_tools_returns_sorted_tools_including_frontend`

This test in `agents::reply_parts` is intermittently flaky — fails in batch runs but passes individually. Root cause unknown. Not related to any recent changes.

### `jsonwebtoken` Default Leeway is 60 Seconds

When testing expired tokens, don't create a token with `exp = now` and expect immediate failure — `jsonwebtoken::Validation` has a 60-second default leeway. Either:
- Set `validation.leeway = 0` explicitly
- Create tokens with `exp` far in the past (e.g., year 1970)

### `just generate-openapi` Deletes `instances.ts`

Every time you run `just generate-openapi`, it deletes `ui/desktop/src/api/instances.ts` (a hand-written wrapper). The `just` recipe automatically restores it via `git checkout`, but if you're running the steps manually, you'll lose the file.

### Test Count Checkpoints

| Crate | Count | Notes |
|---|---|---|
| goose (lib) | 987 | +35 from ACP work (13 policy, 8 audit, 11 quota, 3 RBAC) |
| goose-server | 97 | +10 from ACP work (8 control plane, 2 agent registry) |
| **Total** | **1,084+** | As of commit d373412f |

### Files That Resist `rg` (ripgrep)

Some newly created files (`policy.rs`, `audit.rs`, `quotas.rs`) intermittently fail to be found by `rg` even though they exist on disk (confirmed by `ls -la`, `stat`, `cat`). This appears to be a file indexing/caching issue. Workaround: use `grep` directly or `cat | grep`. The files compile and test correctly regardless.
